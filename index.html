<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Customer Health Score</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --tryvia-dark:#393939; --tryvia-dark2:#222; --tryvia-white:#fff;
      --tryvia-gray:#f5f5f5; --tryvia-gray2:#e2e2e2; --tryvia-border:#c7c7c7;
      --tryvia-cyan:#00cfff; --tryvia-green:#009f42; --tryvia-yellow:#ffc900;
      --tryvia-red:#e53935; --tryvia-blue:#0b63b7;
      --tryvia-shadow:0 2px 18px #0002; --tryvia-card-shadow:0 2px 12px #0003;
      --tryvia-cyan-bg:#e5fbff; --tryvia-gradient:linear-gradient(135deg,#e5fbff 0%,#f5f5f5 100%);
    }

    /* FIXED RESOLUTION LAYOUT */
    html,body{
      background:var(--tryvia-gradient);
      font-family:'Roboto',Arial,sans-serif!important;
      margin:0;
      padding:0;
      text-align:center;
      min-height:100vh;
      width:100%;
      box-sizing:border-box;
      overflow-x:visible;
    }
    /* Reduced top spacing to minimize space above logo/title */
    body{
      display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding-top:6px;
    }

    header{
      background:transparent;
      color:var(--tryvia-dark);
      padding:0.35rem 1rem;
      width:100vw;
      box-sizing:border-box;
      border-bottom:none;
      display:block;
      position:relative;
      height:auto;
    }
    /* header-inner positioned relative to allow absolute centering of title */
    .header-inner{
      max-width:1200px;
      width:100%;
      margin:0 auto;
      display:flex;
      align-items:center;
      gap:1rem;
      justify-content:center;
      padding:0.05rem 0;
      position:relative;
      min-height:64px;
    }

    /* left and right containers positioned to middle of header */
    .header-inner .left{ position:absolute; left: calc(0px - max(0px, (100vw - 1200px)/2)); top:50%; transform:translateY(-50%); display:flex; align-items:center; gap:8px; }
    .header-inner .right{ position:absolute; right:12px; top:50%; transform:translateY(-50%); display:flex; align-items:center; gap:8px; }

    /* logo wrapper for modern/stylish appearance */
    .logo-wrap{
      width:auto;
      height:auto;
      border-radius:12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background:#fff;
      box-shadow:none;
      border:1px solid var(--tryvia-border);
      padding:4px; /* slightly larger than the logo */
      overflow:hidden;
      box-sizing:border-box;
    }
    .logo {
      max-height:48px;
      width:auto;
      display:block;
      vertical-align:middle;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.08));
    }

    #siteTitle{
      font-family:'Poppins', 'Roboto', Arial, sans-serif;
      font-weight:700;
      font-size:2.55rem; /* adjusted to fit nicely with logo */
      color:var(--tryvia-dark);
      letter-spacing:0.4px;
      margin:0;
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      white-space:nowrap;
      text-align:center;
      line-height:1;
    }

    /* New subtitle directly below the main title, Poppins bold and cyan color to match theme */
    #siteSubtitle{
      font-family:'Poppins', 'Roboto', Arial, sans-serif;
      font-weight:700; /* Poppins Bold */
      font-size:1.05rem;
      color:var(--tryvia-cyan);
      letter-spacing:0.6px;
      margin:0;
      position:absolute;
      left:50%;
      top: 70px;
      transform:translate(-50%,-50%);
      pointer-events:none;
      white-space:nowrap;
      text-align:center;
      opacity:0.95;
      text-transform:uppercase;
    }

    .search-input{
      padding:.45rem .7rem;
      border-radius:12px;
      font-size:0.95rem;
      width:260px;
      border:2px solid var(--tryvia-cyan);
      background:var(--tryvia-white);
      color:var(--tryvia-dark);
      box-shadow:var(--tryvia-card-shadow);
      outline:none;
      position:relative;
      z-index:10;
    }
    .search-input::placeholder{ color:#7eaeb9; }
    /* Make readonly search inputs look like a button (since they open a selector) */
    .search-input[readonly]{
      cursor:pointer;
      background:linear-gradient(135deg, #ffffff 0%, #f8feff 100%);
      border:2px solid var(--tryvia-cyan);
      font-weight:700;
    }
    .search-input[readonly]::placeholder{ color:#00a3c7; font-weight:700; }

    .mes-select, .client-modal-mes, .date-select {
      padding:.42rem .8rem;
      border-radius:12px;
      font-size:0.95rem;
      border:2px solid var(--tryvia-cyan);
      background:var(--tryvia-white);
      color:var(--tryvia-dark);
      outline:none;
      box-shadow:var(--tryvia-card-shadow);
      appearance: none;
    }

    .btn{ font-family:inherit; font-weight:700; border-radius:10px; padding:.45rem .8rem; background:var(--tryvia-white); color:var(--tryvia-dark); box-shadow:var(--tryvia-card-shadow); border:1px solid rgba(0,0,0,0.06); cursor:pointer; }
    .btn-primary{ background:var(--tryvia-green); color:#fff; border:1px solid rgba(0,0,0,0.05); }
    /* Toggle extra charts button */
    .toggle-graficos-btn{ background:#007bff; color:#fff; border:none; border-radius:8px; padding:.6rem 1rem; margin:0 0 28px 0; cursor:pointer; box-shadow:var(--tryvia-card-shadow); transition:background-color .2s ease, opacity .2s ease; }
    .toggle-graficos-btn:hover{ background:#0069d9; }
    /* Collapsible container for extra charts */
    #graficosIndividuais.collapsible{ overflow:hidden; max-height:0; opacity:0; transform:translateY(-8px); transition:max-height .36s ease, opacity .36s ease, transform .36s ease; }
    #graficosIndividuais.expanded{ max-height:2000px; opacity:1; margin-top:10px; transform:translateY(0); overflow:visible; }
    .cliente-modal-header{ margin-bottom:10px; }

    .planilha-toggle-btn{ background:var(--tryvia-cyan); color:var(--tryvia-white); border:none; font-weight:bold; border-radius:14px; padding:0.6rem 0.8rem; cursor:pointer; box-shadow:var(--tryvia-card-shadow); font-size:1.25rem; width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; }

    /* smaller ranking order button */
    #rankingOrderBtn { padding:.28rem .46rem; font-size:0.85rem; height:30px; min-width:30px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; }

    /* trend toggle button (Em Queda / Em Alta / Reset) small */
    #rankingTrendBtn { padding:.28rem .46rem; font-size:0.85rem; height:30px; min-width:36px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; background:var(--tryvia-white); border:1px solid rgba(0,0,0,0.06); cursor:pointer; }

    .container{
      width:100%; max-width:100%; margin:.8rem auto 1.6rem; background:var(--tryvia-white); border-radius:28px; box-shadow:var(--tryvia-shadow); padding:1.6rem 1.8rem 1.8rem 1.8rem; display:flex; flex-direction:column; align-items:center; box-sizing:border-box; min-height:720px;
    }

    .planilha-box{ background:var(--tryvia-cyan-bg); border-radius:16px; padding:2.1rem 1.6rem; margin-bottom:1.8rem; border:2px solid var(--tryvia-cyan); width:100%; max-width:820px; box-sizing:border-box; text-align:center; box-shadow:var(--tryvia-card-shadow); display:none; flex-direction:column; align-items:center; justify-content:center; opacity:0; transform:translateY(-12px); transition:all .36s ease; }
    .planilha-box.show{ display:flex; opacity:1; transform:translateY(0); }

    .filters-bar{ width:100%; max-width:1200px; display:flex; align-items:center; gap:12px; margin-bottom:18px; justify-content:flex-start; flex-wrap:wrap; }
    .filters-left{ display:flex; align-items:center; gap:10px; position:relative; } /* relative to position suggestions */
    .filters-left .header-search { position:relative; }
    .filters-actions{ display:flex; gap:8px; align-items:center; margin-left:auto; }

    .date-field{ position:relative; display:inline-flex; align-items:center; }
    .date-field .calendar-icon{ position:absolute; left:10px; font-size:0.95rem; color:var(--tryvia-dark2); pointer-events:none; }
    .date-field select, .date-field .mes-select{ padding-left:34px; }

    /* Suggestions dropdown */
    .suggestions {
      position:absolute;
      top:calc(100% + 8px);
      left:0;
      min-width:260px;
      width:auto;
      max-width:420px;
      background:var(--tryvia-white);
      border:1px solid var(--tryvia-border);
      border-radius:12px;
      box-shadow:0 12px 34px rgba(0,0,0,0.14);
      z-index:16000;
      display:none;
      flex-direction:column;
      overflow:auto;
      max-height:360px;
      font-weight:700;
      text-align:left;
      padding:8px 8px;
      box-sizing:border-box;
    }
    .suggestions.show { display:flex; }
    .suggestion-item { padding:8px 10px; border-radius:10px; cursor:pointer; display:flex; gap:8px; align-items:center; color:var(--tryvia-dark2); font-size:0.95rem; }
    .suggestion-item:hover, .suggestion-item.active {
      background:linear-gradient(90deg, rgba(0,207,255,0.06), rgba(0,207,255,0.04));
    }
    .suggestion-name { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .suggestion-chs { font-weight:800; color:#006f5a; background:linear-gradient(90deg,#e5fbff,#f0fdff); padding:4px 8px; border-radius:8px; border:1px solid var(--tryvia-cyan); }

    /* Subtle style for inline multi-select content inside suggestions */
    .suggestions .modal-search { width:100%; padding:.45rem .6rem; border-radius:10px; border:1px solid var(--tryvia-border); margin:2px 0 6px; font-weight:600; }
    .suggestions .btn { padding:.35rem .6rem; border-radius:8px; font-size:.9rem; }
    .suggestions .compare-selector-item { background:var(--tryvia-white); border-radius:10px; border:1px solid rgba(0,0,0,0.06); box-shadow:var(--tryvia-card-shadow); padding:6px 8px; }
    .suggestions .compare-selector-item:hover { transform:translateY(-2px); box-shadow:0 6px 18px rgba(0,0,0,0.08); }

    /* Floating filters container */
    .floating-filters{ display:none; position:fixed; left:50%; top:8px; transform:translateX(-50%); width:calc(1200px - 200px); max-width:1000px; z-index:12000; pointer-events:auto; transition:opacity .18s ease, transform .18s ease, left .25s ease; }
    .floating-filters .filters-inner{ display:flex; align-items:center; gap:10px; justify-content:flex-start; background:var(--tryvia-white); padding:8px 10px; border-radius:12px; border:2px solid var(--tryvia-cyan); box-shadow:0 8px 30px rgba(0,0,0,0.18); transition:width .22s ease, padding .22s ease, gap .18s ease; overflow:visible; }
    .floating-filters.show{ display:block; opacity:1; transform:translateX(-50%) translateY(0); }
    .floating-filters.hide{ opacity:0; transform:translateX(-50%) translateY(-8px); display:none; }

    .summary-wrapper { width:100%; max-width:100%; margin: 0 0 .6rem 0; display:flex; justify-content:center; }
    .summary { display:flex; gap:1rem; width:auto; flex-wrap:nowrap; justify-content:center; align-items:center; }
    .summary .box { background:var(--tryvia-white); border-radius:18px; padding:1.05rem 1rem; font-size:1.03rem; text-align:center; border:2px solid var(--tryvia-border); min-width:180px; box-shadow:var(--tryvia-card-shadow); font-weight:700; display:flex; flex-direction:column; justify-content:center; align-items:center; cursor:pointer; transition:all .12s ease; }
    .summary .box:hover{ transform:translateY(-4px); box-shadow:0 8px 28px rgba(0,0,0,0.08); }
    .box.saude{ color:var(--tryvia-green); background:#e7faee; border-color:var(--tryvia-green); }
    .box.atencao{ color:var(--tryvia-yellow); background:#fffbe7; border-color:var(--tryvia-yellow); }
    .box.critico{ color:var(--tryvia-red); background:#ffeaea; border-color:var(--tryvia-red); }

    .chs-geral-row{ width:100%; max-width:1200px; display:flex; justify-content:center; margin-bottom:18px; }
    .box.geral{ font-weight:800; font-size:1.05rem; border:2px solid currentColor; background:linear-gradient(135deg,#e7faee 0%, #d4f4dd 100%); color:var(--tryvia-green); position:relative; padding:.9rem .9rem; border-radius:14px; box-shadow:var(--tryvia-card-shadow); min-width:160px; text-align:center; display:flex; flex-direction:column; align-items:center; gap:6px; animation:pulse-health 2s infinite, glowPulse 2.4s ease-in-out infinite; }
    /* Emphasis variables per status */
    #chsGeralBox{ --chs-glow: rgba(16,185,129,0.28); }
    #chsGeralBox.atencao{ --chs-glow: rgba(245,158,11,0.30); }
    #chsGeralBox.critico{ --chs-glow: rgba(239,68,68,0.30); }
    .box.geral .chs-heart{ font-size:1.6rem; display:inline-block; padding:6px; border-radius:50%; background:var(--tryvia-white); box-shadow:var(--tryvia-card-shadow); line-height:1; }
    /* heart/icon color will follow parent status class: */
    .box.geral.saude{ background: linear-gradient(135deg,#e7faee 0%, #d4f4dd 100%); border-color:var(--tryvia-green); color:var(--tryvia-green); }
    .box.geral.saude .chs-heart{ color:var(--tryvia-green); }
    .box.geral.atencao{ background: linear-gradient(135deg,#fffbe7 0%, #fff3c6 100%); border-color:var(--tryvia-yellow); color:var(--tryvia-yellow); }
    .box.geral.atencao .chs-heart{ color:var(--tryvia-yellow); }
    .box.geral.critico{ background: linear-gradient(135deg,#ffeaea 0%, #ffd1d1 100%); border-color:var(--tryvia-red); color:var(--tryvia-red); }
    .box.geral.critico .chs-heart{ color:var(--tryvia-red); }

    @keyframes pulse-health { 0%,100%{transform:scale(1);}50%{transform:scale(1.03);} }

    /* Neon heartbeat glow behind CHS Geral value */
    #chsGeralBox{ position:relative; overflow:visible; }
    #chsGeralBox::after{
      content:""; position:absolute; left:50%; top:58%; width:120px; height:120px; border-radius:50%;
      background:radial-gradient(closest-side, var(--chs-glow), rgba(0,0,0,0) 70%);
      filter: blur(8px); transform:translate(-50%,-50%) scale(0.95); opacity:.75; pointer-events:none;
      animation:heart-glow 1.6s ease-in-out infinite;
    }
    @keyframes heart-glow { 0%,100%{ transform:translate(-50%,-50%) scale(0.92); opacity:.6; } 50%{ transform:translate(-50%,-50%) scale(1.06); opacity:1; } }
    @keyframes glowPulse { 0%,100%{ box-shadow: var(--tryvia-card-shadow), 0 0 0 0 var(--chs-glow); } 50%{ box-shadow: var(--tryvia-card-shadow), 0 0 0 10px var(--chs-glow); } }

    .dashboard-charts-row{width:100%;max-width:100%;display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:.8rem;justify-content:stretch;margin:0 0 .8rem 0;}
    .dashboard-chart-container{ background:var(--tryvia-cyan-bg); border-radius:20px; box-shadow:var(--tryvia-card-shadow); border:2px solid var(--tryvia-cyan); padding:1.25em 1.25em 1.6em 1.25em; width:100%; height:320px; display:grid; grid-template-rows:auto 1fr; align-items:stretch; justify-items:stretch; position:relative; box-sizing:border-box; }
    .chart-toggle-btn{ position:absolute; top:10px; right:12px; width:36px; height:36px; border-radius:10px; background:var(--tryvia-white); border:1px solid rgba(0,0,0,0.06); cursor:pointer; display:inline-flex; align-items:center; justify-content:center; box-shadow:var(--tryvia-card-shadow); }
    .fullscreen-btn{ position:absolute; top:10px; left:12px; right:auto; width:36px; height:36px; border-radius:10px; background:var(--tryvia-white); border:1px solid rgba(0,0,0,0.06); cursor:pointer; display:inline-flex; align-items:center; justify-content:center; box-shadow:var(--tryvia-card-shadow); z-index:3; }
    .dashboard-chart-container .chart-help-btn ~ .fullscreen-btn{ left:54px; right:auto; }
    /* set these titles to black for better emphasis (keeps subtle) */
    .dashboard-chart-container h3{color:#000;font-weight:700;font-size:1.05rem;margin:0 0 .9em 0;letter-spacing:.5px;text-transform:uppercase;padding:0 52px;}
    .dashboard-chart-container > .fullscreen-btn ~ h3{ padding-left: 96px; }
    .dashboard-chart-container .chart-wrapper{ width:100%; height:100%; position:relative; min-height:0; display:flex; align-items:center; justify-content:center; box-sizing:border-box; }
    .dashboard-chart-container canvas{ width:100% !important; height:100% !important; max-width:100% !important; max-height:100% !important; position:relative !important; margin:0 !important; display:block !important; }
    .dashboard-chart-container .chart-wrapper + .chart-wrapper{ margin-top:12px; }
    .dashboard-chart-container:fullscreen, .dashboard-ranking-container:fullscreen{ width:100vw !important; height:100vh !important; max-width:none !important; max-height:none !important; border-radius:0; padding:12px; box-shadow:none; }
    .dashboard-ranking-container:fullscreen{ overflow:auto; }
    .dashboard-ranking-container:fullscreen .dashboard-ranking-list,
    .dashboard-ranking-container:fullscreen #rankingGeralList{ max-height: calc(100vh - 140px) !important; }
    .dashboard-ranking-container:fullscreen h3{ font-size:1.3rem; }
    .dashboard-ranking-container:fullscreen .dashboard-ranking-list li{ font-size:1.15rem; padding:.9em 1.2em; border-radius:16px; }
    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .rank{ min-width:56px; font-size:1rem; padding:.5em 1em; }
    .dashboard-ranking-container:fullscreen .dashboard-ranking-list .score{ font-size:1.05rem; padding:.45em .8em; border-radius:10px; }

    .ranking-pagination{ display:flex; align-items:center; gap:4px; justify-content:center; margin-top:6px; }
    .ranking-pagination #rankingPageInfo{ font-weight:800; color:#000; font-size:.9rem; }
    .ranking-pagination .btn{ padding:.25rem .45rem; font-size:.8rem; border-radius:8px; }
    body.dark-theme .ranking-pagination #rankingPageInfo{ color:#fff; }

    /* Ranking titles */
    #rankingPiores h3, #rankingMelhores h3, .dashboard-ranking-container.ranking-geral h3 { color: #000 !important; font-weight:700; }
    body.dark-theme #rankingPiores h3,
    body.dark-theme #rankingMelhores h3,
    body.dark-theme .dashboard-ranking-container.ranking-geral h3,
    body.dark-theme .dashboard-chart-container h3,
    body.dark-theme h1, body.dark-theme h2 { color:#fff !important; }
    body.dark-theme .ranking-pagination #rankingPageInfo { color:#fff; }
    body.dark-theme .btn { color:#f8fafc; }
    body.dark-theme .help-btn, body.dark-theme .fullscreen-btn, body.dark-theme .chart-toggle-btn { color:#fff; }

    /* Ensure top/bottom rankings show full 5 items without scroll and remain clickable */
    #rankingPiores .dashboard-ranking-list, #rankingMelhores .dashboard-ranking-list{ overflow: visible; max-height: none; }
    #rankingPiores, #rankingMelhores{ height:auto; }
    .dashboard-rankings-row{ align-items: stretch; }

    .dashboard-rankings-row{width:100%;max-width:100%;display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:.8rem;justify-content:stretch;margin:0 0 1.6rem 0;}
.dashboard-rankings-row.one-only{ grid-template-columns: 1fr 1fr 1fr; }
.dashboard-rankings-row.one-only #rankingGeral{ grid-column: 2; }
    .dashboard-ranking-container{background:linear-gradient(135deg, #e5fbff 0%, #f0fdff 100%);border-radius:20px;box-shadow:var(--tryvia-card-shadow);border:2px solid var(--tryvia-cyan);padding:1.1em 1.1em 0.9em 1.1em;width:100%;display:flex;flex-direction:column;align-items:center;position:relative;height:auto; box-sizing:border-box;}
    .dashboard-ranking-container .dashboard-ranking-list{ flex:1 1 auto; width:100%; overflow:auto; margin-top:10px; }
    .dashboard-ranking-container.ranking-geral{ border-color:var(--tryvia-cyan); border-width:2px; background:linear-gradient(135deg, #e5fbff 0%, #f0fdff 100%); height:auto; padding:1.1em 1.1em 0.9em 1.1em; }

    /* TV mode */
    html.tv-html{ width:100vw !important; margin:0 !important; overflow-x:hidden !important; background:#fff !important; }
    body.tv-mode{ overflow:hidden; margin:0 !important; width:100vw !important; overflow-x:hidden !important; background:#fff !important; }
    body.tv-mode header{ display:none !important; }
    body.tv-mode .filters-bar{ display:none !important; }
    body.tv-mode .floating-filters{ display:none !important; }
    body.tv-mode #toggleGraficosBtn{ display:none !important; }
    body.tv-mode #graficosIndividuais{ display:none !important; }
    body.tv-mode .planilha-box{ display:none !important; }
    body.tv-mode .container{ width:100%; max-width:100%; padding:0; margin:0 auto; height:100vh; min-height:0; box-sizing:border-box; background:#fff; border-radius:0; box-shadow:none; }
    body.tv-mode .container.with-sidebar{ width: calc(100vw - 88px); margin-left: 88px; }
    body.tv-mode .summary-wrapper{ width:100%; max-width:none; margin:30px 0 0 0; }
    body.tv-mode .summary{ width:100%; gap:1rem; flex-wrap:nowrap; justify-content:center; box-sizing:border-box; }
    body.tv-mode .summary .box{ min-width:0; width:calc((100% - 4rem)/5); flex:0 1 calc((100% - 4rem)/5); padding:12px 14px; font-size:1.05rem; height:104px; box-sizing:border-box; border-radius:12px; transition: height .2s ease; }
    body.tv-mode .chs-geral-row{ display:none !important; }
    body.tv-mode .box.geral{ padding:12px 14px; min-width:0; max-width:none; height:104px; border-radius:12px; }
    body.tv-mode #chsHeart{ font-size:1.25rem !important; }
    body.tv-mode #chsGeralValor{ font-size:1.2rem !important; }
    body.tv-mode .dashboard-charts-row{ width:100%; max-width:none; gap:.5rem; margin:30px 0 10px 0; justify-content:center; flex-wrap:nowrap; padding:0 .25rem; box-sizing:border-box; }
    body.tv-mode .dashboard-charts-row.tv-four .dashboard-chart-container{ width: calc((100% - 1.5rem)/4); flex:0 1 calc((100% - 1.5rem)/4); min-width:0; }
    /* 3 charts layout (applied by JS with class tv-three) */
    body.tv-mode .dashboard-charts-row.tv-three .dashboard-chart-container{ width: calc((100% - 1rem)/3); flex:0 1 calc((100% - 1rem)/3); min-width:0; }
    body.tv-mode .dashboard-chart-container { height: 420px; padding: 10px 8px 12px 8px; transition: height .28s ease; }
    body.tv-mode .dashboard-chart-container h3{ font-size:.9rem; margin:0 0 4px 0; padding:0 12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; text-align:center; }
    body.tv-mode .dashboard-chart-container .ranking-card-header{ justify-content:center; }
    body.tv-mode .dashboard-chart-container .ranking-card-header h3{ position:static; left:auto; transform:none; width:100%; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    body.tv-mode .chart-help-btn, body.tv-mode .chart-toggle-btn, body.tv-mode .fullscreen-btn{ display:none !important; }
    body.tv-mode .dashboard-ranking-container h3{ margin:0 0 10px 0; font-size:1.05rem; text-align:center; }
    body.tv-mode #rankingGeral .ranking-card-header{ justify-content:center; gap:8px; margin-bottom:10px; }
    body.tv-mode #rankingGeral .ranking-card-header h3{ margin:0; font-size:1.05rem; text-align:center; position:static; left:auto; transform:none; width:100%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    body.tv-mode .dashboard-rankings-row{ width:100%; max-width:none; gap:.75rem; margin:30px 0 0 0; justify-content:center; align-items:stretch; flex-wrap:nowrap; padding:0 .5rem; box-sizing:border-box; }
    body.tv-mode .dashboard-ranking-container{ width:32%; max-width:none; min-width:0; height:420px; padding:10px; display:flex; flex-direction:column; }
    body.tv-mode .dashboard-ranking-list{ max-height:352px; margin-top:8px; padding-bottom:12px; scroll-padding-bottom:12px; box-sizing:border-box; flex:1 1 auto; overflow:auto; }
    body.tv-mode #rankingGeralList{ max-height:352px; margin-top:8px; padding-bottom:12px; scroll-padding-bottom:12px; box-sizing:border-box; flex:1 1 auto; overflow:auto; }
    body.tv-mode .dashboard-ranking-list li:last-child{ margin-bottom:0; }
    body.tv-mode #rankingFiltersWrap{ display:none !important; }
    body.tv-mode #indicatorFiltersWrap{ display:none !important; }
    body.tv-mode .dashboard-ranking-container.ranking-geral{ width:32%; max-width:none; min-width:0; height:420px; padding:10px; background:var(--tryvia-white); border-width:2px; border-color:var(--tryvia-cyan); }
    body.tv-mode .dashboard-rankings-row.tv-three .dashboard-ranking-container{ width: calc((100% - 1.5rem)/3); flex:0 1 calc((100% - 1.5rem)/3); min-width:0; }

    /* Show rankings in TV mode (3 col layout handled by JS/CSS) */
    /* Intencionalmente sem ocultar rankings no modo TV */

    /* TV Mode visual polish */
    body.tv-mode .summary .box{ background:#f9fbfc; border:1px solid #e6eef3; box-shadow: 0 6px 24px rgba(16,42,67,0.08); }
    body.tv-mode .summary .box:hover{ transform:translateY(-3px); box-shadow:0 10px 28px rgba(16,42,67,0.12); }
    body.tv-mode .summary .box::before{ content:""; display:inline-flex; align-items:center; justify-content:center; width:26px; height:26px; border-radius:8px; background:#e9f4fb; color:#0b63b7; border:1px solid #d3e7f3; box-shadow:0 2px 8px rgba(11,99,183,0.08); margin-bottom:6px; }
    body.tv-mode .summary .box:nth-child(1)::before{ content:"ðŸ‘¥"; }
    body.tv-mode .summary .box:nth-child(2)::before{ content:"ðŸ’š"; }
    body.tv-mode .summary .box:nth-child(3)::before{ content:"âš ï¸"; }
    body.tv-mode .summary .box:nth-child(4)::before{ content:"â›”"; }
    body.tv-mode .summary .box:nth-child(5)::before{ content:"ðŸ“Š"; }

    /* Ranking list polish + medals */
    body.tv-mode .dashboard-ranking-list li{ background:linear-gradient(180deg,#f9fcff,#f3f9fd); border:1px solid #e3eef5; box-shadow:0 4px 16px rgba(16,42,67,0.06); position:relative; overflow:hidden; }
    body.tv-mode .dashboard-ranking-list li > *{ position:relative; z-index:1; }
    body.tv-mode .dashboard-ranking-list .perf-meter{ position:absolute; left:0; top:0; bottom:0; width:0; background:linear-gradient(90deg, rgba(0,159,66,0.14), rgba(0,207,255,0.10)); z-index:0; }
    body.tv-mode .dashboard-ranking-list .rank{ border-color:#d3e7f3; color:#0b63b7; background:#fff; }
    body.tv-mode .dashboard-ranking-list .rank.gold{ border-color:#e2b100; color:#996c00; background:linear-gradient(180deg,#fff3bf,#fde68a); box-shadow:0 4px 16px rgba(226,177,0,0.25); }
    body.tv-mode .dashboard-ranking-list .rank.silver{ border-color:#c3c7d1; color:#5c6370; background:linear-gradient(180deg,#f5f7fb,#e9edf5); box-shadow:0 4px 16px rgba(92,99,112,0.2); }
    body.tv-mode .dashboard-ranking-list .rank.bronze{ border-color:#d59a6a; color:#7a4d2b; background:linear-gradient(180deg,#ffe3cc,#ffd7b8); box-shadow:0 4px 16px rgba(122,77,43,0.2); }
    body.tv-mode .dashboard-ranking-list .score{ border-radius:10px; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4); }

    /* Optional fixed sidebar for navigation (TV only) */
    .tv-sidebar{ position:fixed; left:0; top:0; width:88px; height:100vh; background:linear-gradient(180deg,#0e2a47,#0b1f36); border-right:1px solid rgba(255,255,255,0.06); box-shadow: 0 8px 30px rgba(0,0,0,0.25); z-index:20040; display:flex; flex-direction:column; align-items:center; padding:14px 8px; box-sizing:border-box; }
    .tv-sidebar .tv-brand{ width:48px; height:48px; border-radius:12px; display:flex; align-items:center; justify-content:center; font-weight:900; color:#fff; background:linear-gradient(135deg,#0b63b7,#00cfff); border:2px solid rgba(255,255,255,0.18); box-shadow:0 6px 18px rgba(0,0,0,0.25); margin-bottom:16px; letter-spacing:.6px; }
    .tv-sidebar .tv-nav{ display:flex; flex-direction:column; gap:10px; width:100%; }
    .tv-sidebar .tv-nav-item{ width:100%; border:none; border-radius:12px; background:rgba(255,255,255,0.06); color:#e6eef3; font-weight:800; font-size:.78rem; padding:10px 6px; cursor:pointer; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08); transition:all .16s ease; }
    .tv-sidebar .tv-nav-item:hover{ background:rgba(255,255,255,0.12); transform:translateY(-2px); }
    .tv-sidebar .tv-nav-item:active{ transform:translateY(0); }

    /* TV mode exit button */
    .tv-exit-btn{ position:fixed; top:10px; right:12px; z-index:20050; display:none; padding:8px 12px; border-radius:10px; border:2px solid var(--tryvia-cyan); background:var(--tryvia-white); color:var(--tryvia-cyan); box-shadow:var(--tryvia-card-shadow); font-weight:700; cursor:pointer; }
    body.tv-mode .tv-exit-btn{ display:inline-flex; align-items:center; justify-content:center; }

    /* header inside ranking card to align title and small button horizontally */
    .ranking-card-header { width:100%; display:flex; align-items:center; gap:8px; justify-content:flex-end; margin-bottom:10px; position:relative; }

    /* Plano de AÃ§Ã£o overlay */
    .plano-acao-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.35); z-index:20010; display:flex; align-items:center; justify-content:center; overflow:auto; min-height:100vh; padding:24px 20px; }
    .plano-acao-box{ background:var(--tryvia-white); border-radius:14px; border:2px solid var(--tryvia-cyan); box-shadow:var(--tryvia-card-shadow); width:92%; max-width:820px; max-height:none; overflow:visible; padding:16px; text-align:left; position:relative; }
    .plano-acao-box h3{ margin:0 0 8px 0; color:#000; font-size:1.15rem; }
    .plano-acao-box h4{ margin:10px 0 6px 0; color:var(--tryvia-cyan); font-size:1.02rem; }
    .plano-acao-box ul{ margin:6px 0 10px 18px; padding:0; }
    .plano-acao-box li{ margin:4px 0; }
    .plano-acao-actions{ display:flex; justify-content:flex-end; margin-top:10px; }
    .plano-acao-close{ position:absolute; top:10px; right:10px; background:#c7c7c7; color:#000; border:none; border-radius:8px; padding:.3rem .6rem; font-weight:800; cursor:pointer; }
    .plano-acao-trigger{ display:flex; justify-content:center; margin-top:10px; }
    .plano-acao-trigger .btn{ padding:.65rem 1.1rem; font-size:1.05rem; min-width:200px; }

    /* Help modal */
    .help-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:20020; display:flex; align-items:center; justify-content:center; padding:16px; }
    .help-box{ background:var(--tryvia-white); border:2px solid var(--tryvia-cyan); border-radius:16px; width:96%; max-width:980px; max-height:86vh; overflow:auto; padding:18px; box-shadow:0 18px 46px rgba(0,0,0,0.28); position:relative; text-align:left; }
    .help-close{ position:absolute; top:12px; right:12px; background:#c7c7c7; color:#000; border:none; border-radius:10px; padding:.4rem .7rem; font-weight:800; cursor:pointer; }
    .help-btn{ width:32px; height:32px; border-radius:50%; font-weight:900; background:#e9eef0; color:#000; border:1px solid var(--tryvia-border); display:inline-flex; align-items:center; justify-content:center; line-height:1; }

    /* Help content layout */
    .help-hero{ display:flex; align-items:stretch; gap:16px; background:linear-gradient(90deg,#f0fdff,#e5fbff); border:1px solid var(--tryvia-cyan); border-radius:14px; padding:14px; }
    .help-hero .hero-left{ flex:1; display:flex; flex-direction:column; gap:8px; }
    .help-hero .hero-title{ font-size:1.4rem; font-weight:900; color:#000; display:flex; align-items:center; gap:8px; }
    .help-hero .hero-sub{ color:#0b63b7; font-weight:700; }
    .help-hero .pill-group{ display:flex; flex-wrap:wrap; gap:8px; margin-top:4px; }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:.35rem .55rem; border-radius:999px; border:2px solid var(--tryvia-border); font-weight:800; background:#fff; }
    .pill .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    .pill.saude{ border-color:#009f42; }
    .pill.saude .dot{ background:#009f42; }
    .pill.atencao{ border-color:#ffc900; }
    .pill.atencao .dot{ background:#ffc900; }
    .pill.critico{ border-color:#e53935; }
    .pill.critico .dot{ background:#e53935; }
    .help-hero .hero-right{ flex:0 0 260px; width:260px; min-width:220px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; background:#fff; border:1px dashed var(--tryvia-cyan); border-radius:12px; padding:10px; box-sizing:border-box; }
    .help-hero .legend{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; font-weight:700; }
    .legend-item{ display:inline-flex; align-items:center; gap:6px; padding:.2rem .45rem; border-radius:999px; background:#f7fafb; border:1px solid var(--tryvia-border); }
    .legend-item .dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    .legend-sla .dot{ background:#0b63b7; }
    .legend-nps .dot{ background:#6b43b8; }
    .legend-neg .dot{ background:#e53935; }
    .legend-cs .dot{ background:#009f42; }
    .help-hero .hero-right canvas{ width:200px !important; height:200px !important; max-width:200px; max-height:200px; display:block; }

    .help-grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:14px; }
    .help-tile{ background:#fff; border:2px solid var(--tryvia-cyan); border-radius:12px; box-shadow:var(--tryvia-card-shadow); padding:12px; display:flex; gap:10px; align-items:flex-start; }
    .help-tile .tile-icon{ font-size:1.4rem; }
    .help-tile h4{ margin:0 0 6px 0; color:#000; }
    .help-tile p{ margin:0; }

    .help-section{ background:#fff; border:1px solid var(--tryvia-border); border-radius:12px; padding:12px; margin-top:12px; }
    .help-section h4{ margin:0 0 8px 0; color:#0b63b7; }

    @media (max-width:900px){
      .help-box{ width:96%; padding:12px; }
      .help-hero{ flex-direction:column; }
      .help-hero .hero-right{ width:100%; }
      .help-grid{ grid-template-columns:1fr; }
    }
    /* CHS top badge and chart title */
    .chs-top-badge{ display:inline-block; background:linear-gradient(90deg,#e5fbff,#f0fdff); border:2px solid var(--tryvia-cyan); color:#000; font-weight:800; padding:.4rem .7rem; border-radius:12px; box-shadow:var(--tryvia-card-shadow); margin:4px 0 8px 0; }
    .chart-title{ font-weight:800; color:#000; font-size:.95rem; margin:0 0 6px 0; display:flex; align-items:center; gap:6px; }
    .chart-title .dot{ width:8px; height:8px; border-radius:50%; background:var(--tryvia-cyan); display:inline-block; }

    /* Chart help icon with tooltip */
    .chart-help{ display:inline-flex; align-items:center; justify-content:center; width:22px; height:22px; margin-right:8px; border-radius:50%; background:var(--tryvia-white); color:var(--tryvia-cyan); font-weight:900; font-size:0.9rem; border:2px solid var(--tryvia-cyan); cursor:default; position:relative; }
    .chart-help::after{ content: attr(data-tip); position:absolute; bottom:100%; left:50%; transform: translate(-50%, -8px); background:rgba(0,0,0,0.9); color:#fff; padding:8px 10px; border-radius:10px; white-space:normal; max-width:340px; width:max-content; pointer-events:none; opacity:0; transition:opacity .12s ease, transform .12s ease; z-index:21000; box-shadow:0 8px 26px rgba(0,0,0,0.36); }
    .chart-help:hover::after{ opacity:1; transform: translate(-50%, -12px); }
    .chart-help-btn{ position:absolute; top:10px; left:12px; width:36px; height:36px; border-radius:10px; background:var(--tryvia-white); color:var(--tryvia-cyan); border:1px solid rgba(0,0,0,0.06); cursor:default; display:inline-flex; align-items:center; justify-content:center; font-weight:900; box-shadow:var(--tryvia-card-shadow); }
    .chart-help-btn::after{ content: attr(data-tip); position:absolute; bottom:100%; left:50%; transform: translate(-50%, -8px); background:rgba(0,0,0,0.9); color:#fff; padding:8px 10px; border-radius:10px; white-space:normal; max-width:340px; width:max-content; pointer-events:none; opacity:0; transition:opacity .12s ease, transform .12s ease; z-index:21000; box-shadow:0 8px 26px rgba(0,0,0,0.36); }
    .chart-help-btn:hover::after{ opacity:1; transform: translate(-50%, -12px); }

    /* PDCA styling */
    .pdca-grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:10px; margin-top:10px; }
    .pdca-card{ background:var(--tryvia-white); border:2px solid var(--tryvia-cyan); border-radius:12px; padding:10px; box-shadow:var(--tryvia-card-shadow); }
    .pdca-card .pdca-head{ display:flex; align-items:center; gap:8px; font-weight:800; color:#000; margin-bottom:6px; }
    .pdca-icon{ font-size:1.1rem; }
    .pdca-plan{ border-color:#0b63b7; }
    .pdca-do{ border-color:#009f42; }
    .pdca-check{ border-color:#ffc900; }
    .pdca-act{ border-color:#e53935; }
    /* Center the h3 horizontally inside the card using absolute centering so it aligns in middle of card horizontally */
    .ranking-card-header h3 { margin:0; position:absolute; left:50%; transform:translateX(-50%); font-size:1.05rem; color:#000; font-weight:700; text-align:center; white-space:nowrap; }
    .ranking-order-wrap { display:flex; align-items:center; gap:8px; position:relative; z-index:2; }

    /* Filters dropdown (for Ranking Geral) */
    .filters-menu { position:absolute; top:100%; right:0; margin-top:6px; background:var(--tryvia-white); border:1px solid var(--tryvia-border); border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.12); padding:6px; display:none; min-width:160px; z-index:10; }
    .filters-item { display:block; width:100%; text-align:left; background:transparent; border:none; padding:8px 10px; border-radius:8px; font-weight:700; color:var(--tryvia-dark2); cursor:pointer; }
    .filters-item:hover { background:linear-gradient(90deg, rgba(0,207,255,0.06), rgba(0,207,255,0.04)); }
    .filters-menu .separator { height:1px; background:var(--tryvia-gray2); margin:4px 0; border-radius:1px; }

    /* small delta badge to indicate change from previous month */
    .delta-badge { display:inline-flex; align-items:center; gap:6px; font-weight:800; font-size:0.82rem; padding:.18rem .5rem; border-radius:999px; color:#fff; min-width:36px; justify-content:center; box-shadow:0 4px 12px rgba(0,0,0,0.08); margin-left:8px; }
    .delta-up { background: linear-gradient(90deg,#0fb06a,#007a33); color:#fff; }
    .delta-down { background: linear-gradient(90deg,#ff7b7b,#e53935); color:#fff; }
    .delta-neutral { background:linear-gradient(90deg,#e9eef0,#dfeef4); color:#006f5a; }

    #rankingGeralList{ width:100%; list-style:none; margin:0; padding:0; max-height:320px; overflow:auto; display:block; }

    .dashboard-ranking-list{width:100%;list-style:none;margin:0;padding:0;max-height:320px;overflow:auto;}
    .dashboard-ranking-list li{display:flex;align-items:center;justify-content:space-between;background:var(--tryvia-cyan-bg);border-radius:12px;box-shadow:0 2px 8px #00cfff11;border:2px solid var(--tryvia-cyan);margin-bottom:.45em;padding:.42em .65em;font-size:.9em;font-weight:600;color:var(--tryvia-dark2);cursor:pointer;transition:all .3s ease;}
    .dashboard-ranking-list li:last-child{ margin-bottom: 0; }
    .dashboard-ranking-list li:hover{transform:translateY(-2px);box-shadow:0 4px 15px rgba(0,207,255,0.2);}
    .dashboard-ranking-list .rank{background:var(--tryvia-white);color:var(--tryvia-cyan);border-radius:50px;font-size:.78rem;font-weight:700;padding:.35em .7em;margin-right:.7em;border:2px solid var(--tryvia-cyan);box-shadow:0 1px 6px #00cfff09;min-width:36px;text-align:center;}
    .dashboard-ranking-list .client{flex:1;text-align:left;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:.3em;display:flex;align-items:center;gap:.5rem;position:relative;}
    .dashboard-ranking-list .score{margin-left:.6em;font-size:.9em;color:var(--tryvia-white);font-weight:700;padding:.28em .55em;border-radius:8px;min-width:46px;text-align:center;}
    .dashboard-ranking-list .perf-meter{ display:none; }

    

    .table-region{ display: none !important; }

    /* Modal-centered overlay styles (ensure select/compare open as overlay, centered) */
    .compare-selector-modal, .compare-modal {
      position:fixed;
      top:0;
      left:0;
      width:100vw;
      height:100vh;
      background:rgba(0,0,0,0.7);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:14000;
      font-family:'Roboto',Arial,sans-serif!important;
    }
    .compare-selector-box, .compare-modal-box, .compare-selector-box .compare-selector-list {
      box-sizing:border-box;
    }
    .compare-selector-box, .compare-modal-box {
      width:95%;
      max-width:760px;
      background:var(--tryvia-white);
      border-radius:12px;
      padding:12px;
      box-shadow:var(--tryvia-card-shadow);
      border: 3px solid var(--tryvia-cyan);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    /* Standardized modal header/body for select/compare */
    .modal-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding-bottom:8px;
      border-bottom:1px solid var(--tryvia-gray2);
    }
    .modal-title { font-weight:800; color:var(--tryvia-cyan); font-size:1rem; }
    .modal-controls { display:flex; gap:8px; align-items:center; }

    .modal-body { display:flex; gap:12px; align-items:flex-start; }
    .modal-body .list-area { flex:1; min-width:220px; max-height:360px; overflow:auto; padding:6px; display:flex; flex-direction:column; gap:8px; }
    .modal-body .info-area { width:320px; max-width:40%; min-width:220px; background:var(--tryvia-cyan-bg); border-radius:12px; padding:10px; border:2px solid var(--tryvia-cyan); box-shadow:var(--tryvia-card-shadow); display:flex; flex-direction:column; gap:8px; align-items:flex-start; justify-content:flex-start; }

    .compare-selector-list, #selectModalList { width:100%; display:flex; flex-direction:column; gap:8px; }
    .compare-selector-item {
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:10px;
      background:var(--tryvia-white);
      border:1px solid rgba(0,0,0,0.06);
      box-shadow:var(--tryvia-card-shadow);
      font-weight:700;
      cursor:pointer;
    }
    .compare-selector-item:hover{ transform:translateY(-3px); box-shadow:0 8px 20px rgba(0,0,0,0.06); }
    .compare-selector-item input[type="checkbox"]{ width:18px; height:18px; margin:0; accent-color: var(--tryvia-cyan); }
    .compare-selector-item span.client-name { flex:1; text-align:left; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .compare-selector-item .chs-badge { font-weight:800; color:#006f5a; padding:.25rem .6rem; border-radius:8px; background:linear-gradient(90deg,#e5fbff,#f0fdff); border:1px solid var(--tryvia-cyan); min-width:56px; text-align:center; }

    /* Make modal action buttons consistent */
    .modal-actions { display:flex; justify-content:flex-end; gap:8px; padding-top:6px; border-top:1px solid transparent; }
    .modal-actions .btn{ min-width:110px; }

    /* Improve text smoothing and rendering across UI (including modals) */
    body, .cliente-modal-box, .compare-modal-box, .plano-acao-box {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }
    /* Hint sharper canvas rendering */
    .cliente-modal-box canvas { image-rendering: -webkit-optimize-contrast; }

    /* Compare chart modal - standardized */
    .compare-modal-box { max-width:880px; width:92%; padding:14px; }
    .compare-modal-box .modal-body { flex-direction:column; }
    .compare-modal-box canvas { width:100% !important; height:360px !important; }
    .cliente-modal-right > div { overflow:hidden; }
    .cliente-modal-right canvas { display:block; max-width:100%; animation:none !important; }

    /* client modal overlay already used elsewhere - keep consistent */
    .details-modal,.edit-modal,.call-modal,.cliente-modal{position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.75);display:none;align-items:center;justify-content:center;z-index:13000;font-family:'Roboto',Arial,sans-serif!important; will-change: opacity; overflow:auto; }
    .cliente-modal-box{ background:var(--tryvia-white); border-radius:16px; max-width:760px; width:92vw; padding:1.1rem; border:2px solid var(--tryvia-cyan); box-shadow:0 18px 46px rgba(0,0,0,0.28); max-height:82vh; overflow:visible; text-align:left; position:relative; will-change: transform, opacity; backface-visibility:hidden; transform: translateZ(0); }
    .cliente-modal-box .close-modal{ position:absolute; top:10px; right:10px; background:var(--tryvia-red); color:var(--tryvia-white); border:none; font-size:0.95rem; border-radius:8px; padding:.3rem .5rem; cursor:pointer; }
    .modal-search { width:100%; padding:.5rem .6rem; border-radius:10px; border:1px solid var(--tryvia-border); margin-bottom:.6rem; }

    @keyframes modalSlideIn { from { transform: translateY(-8px); opacity:0; } to { transform: translateY(0); opacity:1; } }

    /* Smooth global animations */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    @keyframes slideUpIn { from { transform: translateY(10px); opacity:0; } to { transform: translateY(0); opacity:1; } }
    @keyframes slideDownOut { from { transform: translateY(0); opacity:1; } to { transform: translateY(8px); opacity:0; } }
    @keyframes scaleIn { from { transform: scale(0.98); opacity:0; } to { transform: scale(1); opacity:1; } }
    .fade-in { animation: fadeIn .24s ease both; }
    .fade-out { animation: fadeOut .22s ease both; }
    .slide-up-in { animation: slideUpIn .26s ease both; }
    .slide-down-out { animation: slideDownOut .22s ease both; }
    .scale-in { animation: scaleIn .24s ease both; }
    .chart-anim { will-change: opacity, transform; }

    /* Additional floating collapse/expand styles (subtle, site-standard) */
    .floating-filters .header-search { display:flex; align-items:center; gap:8px; position:relative; }
    .floating-filters .header-search .search-icon { display:inline-flex; align-items:center; justify-content:center; width:40px; height:40px; border-radius:10px; background:var(--tryvia-cyan); color:var(--tryvia-white); box-shadow:var(--tryvia-card-shadow); font-size:1.05rem; }
    .floating-filters .filters-inner .collapse-btn { width:36px; height:36px; border-radius:8px; background:var(--tryvia-white); border:1px solid rgba(0,0,0,0.06); display:inline-flex; align-items:center; justify-content:center; cursor:pointer; box-shadow:var(--tryvia-card-shadow); color:var(--tryvia-cyan); font-weight:800; transition:transform .18s ease; }
    .floating-filters .filters-inner .collapse-btn:active { transform:scale(.98); }

    /* collapsed state: keep only icon + collapse button and move to right edge (logo stays alone on left) */
    .floating-filters.collapsed { right:12px !important; left:auto !important; top:12px !important; transform:none !important; width:auto !important; }
    .floating-filters.collapsed .filters-inner { width:56px !important; padding:6px !important; gap:6px !important; justify-content:center; }
    .floating-filters .filters-inner.collapsed { width:56px !important; padding:6px !important; gap:6px !important; justify-content:center; }
    .floating-filters .filters-inner.collapsed .search-input { display:none !important; }
    .floating-filters .filters-inner.collapsed .date-field { display:none !important; }
    .floating-filters .filters-inner.collapsed > div[style*="display:flex"] { display:none !important; } /* hides last buttons block */
    .floating-filters .filters-inner.collapsed .search-icon { margin-right:0; }

    /* small fade/slide for expand transition */
    .floating-filters .filters-inner { transition: width .22s ease, padding .22s ease, gap .18s ease, left .25s ease; }
    .floating-filters .filters-inner .search-input { transition:opacity .18s ease; }
    .floating-filters .filters-inner .date-field { transition:opacity .18s ease; }

    /* keep little pill look consistent on hover */
    .floating-filters .filters-inner:hover .collapse-btn { box-shadow:0 8px 24px rgba(0,0,0,0.08); }

    /* accessibility focus */
    .floating-filters .filters-inner .collapse-btn:focus { outline:3px solid rgba(0,207,255,0.18); outline-offset:2px; }

    /* Ensure when collapsed the floating bar is above other items */
    .floating-filters.collapsed { z-index:14000; }

    /* ---------- Tooltip for nota-rect ---------- */
    .nota-rect { position:relative; overflow:visible; }
    /* Tooltip: show above the note and allow overflow beyond modal */
    .nota-tooltip {
      display:inline-block;
      position:absolute;
      top:-6px;
      left:50%;
      transform:translate(-50%, -100%);
      background:rgba(0,0,0,0.9);
      color:#fff;
      padding:10px 12px;
      border-radius:10px;
      font-size:0.92rem;
      line-height:1.25;
      white-space:nowrap;              /* keep single line for horizontal growth */
      max-width:none;                  /* let it overflow horizontally */
      overflow:visible;
      overflow-wrap:normal;
      word-break:normal;
      pointer-events:none;
      opacity:0;
      transition:opacity .12s ease, transform .12s ease;
      z-index:15000;
      box-shadow:0 8px 26px rgba(0,0,0,0.36);
    }
    .nota-rect:hover .nota-tooltip { opacity:1; transform:translate(-50%, calc(-100% - 8px)); }

    /* Prevent text cutoff in modals */
    .cliente-modal-box, .compare-selector-box, .compare-modal-box, .plano-acao-box {
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    @media (max-width:900px){
      .cliente-modal-box{max-width:95%;padding:1rem;} 
      .cliente-modal-body{flex-direction:column;} 
      .cliente-modal-box canvas{height:180px!important;} 
      .compare-selector-box{ max-width:94%; }
      .compare-modal-box{ max-width:95%; }
      .modal-body { flex-direction:column; }
      .modal-body .info-area { width:100%; }
      .header-inner .left, .header-inner .right { position:static; transform:none; margin:4px; }
      #siteTitle{ position:static; transform:none; margin:0 auto 6px; font-size:1.25rem; }
      .logo-wrap{ margin:0 auto 8px; }
      #siteSubtitle { position:static; transform:none; margin:0 auto 4px; font-size:0.95rem; font-weight:700; }
      .floating-filters { display:none !important; }
      /* On small screens ensure wrapping and near-full width */
      .suggestions { max-width:90vw; min-width:180px; left:0; right:auto; }
      .search-input{ width:180px; }
      .nota-tooltip { white-space:normal; max-width:90vw; overflow-wrap:break-word; word-break:break-word; }
    }
    /* Tema escuro: paleta em tons de preto, harmonizada com acentos */
    body.dark-theme{
      --tryvia-dark:#e6e6e6; --tryvia-dark2:#cfd2d6; --tryvia-white:#0a0a0a;
      --tryvia-gray:#0a0a0a; --tryvia-gray2:#111111; --tryvia-border:#1a1a1a;
      --tryvia-cyan:#22d3ee; --tryvia-green:#34d399; --tryvia-yellow:#fbbf24;
      --tryvia-red:#f87171; --tryvia-blue:#60a5fa;
      --tryvia-shadow:0 10px 34px rgba(0,0,0,0.60); --tryvia-card-shadow:0 8px 26px rgba(0,0,0,0.65);
      --tryvia-cyan-bg:#0d0d0d; --tryvia-gradient:#0a0a0a;
    }
    body.dark-theme header{ background:linear-gradient(180deg, rgba(10,10,10,0.96), rgba(10,10,10,0.82)); border-bottom:1px solid #1a1a1a; }
    body.dark-theme .container{ background:#0b0b0b; box-shadow:var(--tryvia-shadow); }
    body.dark-theme .dashboard-chart-container{ background:#0e0e0e; border-color:#1a1a1a; }
    body.dark-theme .dashboard-ranking-container{ background:#0e0e0e; border-color:#1a1a1a; }
    body.dark-theme .summary .box{ background:#121212; border-color:#1a1a1a; color: var(--tryvia-dark); }
    body.dark-theme .summary .box:hover{ box-shadow: 0 8px 28px rgba(0,0,0,0.35); }
    body.dark-theme .logo-wrap{ background:#ffffff; border-color:#2a2a2a; }
    body.dark-theme #chsTotal{ background:#121212; border-color:#2a2a2a; color:var(--tryvia-dark); }
    body.dark-theme #chsTotal b{ color:var(--tryvia-dark); }
    body.dark-theme .logo{ filter: invert(1) brightness(0.92); }
    body.dark-theme .floating-filters .filters-inner{ background:#0f0f0f; border-color:#1a1a1a; }
    body.dark-theme .search-input{ background:#0f0f0f; color:var(--tryvia-dark); border-color:var(--tryvia-cyan); }
    body.dark-theme .search-input::placeholder{ color:#8aa1a8; }
    body.dark-theme .mes-select, body.dark-theme .client-modal-mes, body.dark-theme .date-select{ background:#0f0f0f; color:var(--tryvia-dark); border-color:var(--tryvia-cyan); }
    body.dark-theme .suggestions{ background:#0f0f0f; border-color:#1a1a1a; box-shadow:0 12px 34px rgba(0,0,0,0.6); }
    body.dark-theme .suggestion-item{ color:var(--tryvia-dark2); }
    body.dark-theme .suggestion-item:hover, body.dark-theme .suggestion-item.active{ background:linear-gradient(90deg, rgba(34,211,238,0.12), rgba(34,211,238,0.08)); }
    body.dark-theme .filters-menu{ background:#0f0f0f; border-color:#1a1a1a; box-shadow:0 10px 30px rgba(0,0,0,0.6); }
    body.dark-theme .filters-item{ color:var(--tryvia-dark2); }
    body.dark-theme .filters-item:hover{ background:linear-gradient(90deg, rgba(34,211,238,0.12), rgba(34,211,238,0.08)); }
    body.dark-theme .dashboard-ranking-list li{ background:#121212; border-color:#1a1a1a; color:var(--tryvia-dark2); box-shadow:0 2px 8px rgba(0,0,0,0.25); }
    body.dark-theme .dashboard-ranking-list li:hover{ box-shadow:0 4px 15px rgba(0,0,0,0.35); }
    body.dark-theme .dashboard-ranking-list .rank{ background:#0d0d0d; color:var(--tryvia-cyan); border-color:var(--tryvia-cyan); }
    body.dark-theme .btn{ background:#111111; color:var(--tryvia-dark); border-color:#1a1a1a; }
    body.dark-theme .help-box, body.dark-theme .plano-acao-box, body.dark-theme .compare-selector-box, body.dark-theme .compare-modal-box{ background:#0b0b0b; border-color:#1a1a1a; box-shadow:0 18px 46px rgba(0,0,0,0.5); }
    body.dark-theme .help-hero, body.dark-theme .help-section, body.dark-theme .help-tile{ background:#0f0f0f !important; border-color:#1a1a1a !important; }
    body.dark-theme .legend-item{ background:#111111; border-color:#1a1a1a; }
    body.dark-theme .box.saude{ background:#0f1914; }
    body.dark-theme .box.atencao{ background:#1a1609; }
    body.dark-theme .box.critico{ background:#1a0b0b; }
  </style>
</head>
<body>
  <header>
    <div class="header-inner" role="banner">
      <div class="left">
        <!-- external logo provided by user, styled to fit with title -->
        <div class="logo-wrap" aria-hidden="true">
          <img class="logo" src="https://tryvia.github.io/dev/logo1.png" alt="Logo">
        </div>
      </div>

      <div class="title-wrapper">
        <h1 id="siteTitle">Customer Health Score</h1>
        <h2 id="siteSubtitle">DASHBOARD DA SAÃšDE DO CLIENTE</h2>
      </div>

      <div class="right">
        <button class="btn" id="themeToggleBtn" type="button" title="Alternar tema">ðŸŒ™</button>
      </div>
    </div>
  </header>
  <script>
    (function(){
      function applyTheme(t){
        const isDark = (t === 'dark');
        document.body.classList.toggle('dark-theme', isDark);
        const btn = document.getElementById('themeToggleBtn');
        if(btn){ btn.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™'; btn.title = isDark ? 'Alternar para tema claro' : 'Alternar para tema escuro'; }
      }
      const saved = (localStorage.getItem('theme') || 'light');
      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', function(){
          applyTheme(saved);
          const btn = document.getElementById('themeToggleBtn');
          if(btn){ btn.addEventListener('click', function(){ const next = document.body.classList.contains('dark-theme') ? 'light' : 'dark'; localStorage.setItem('theme', next); applyTheme(next); }); }
        });
      } else {
        applyTheme(saved);
        const btn = document.getElementById('themeToggleBtn');
        if(btn){ btn.addEventListener('click', function(){ const next = document.body.classList.contains('dark-theme') ? 'light' : 'dark'; localStorage.setItem('theme', next); applyTheme(next); }); }
      }
    })();
  </script>

  <div class="container">
    <div class="filters-bar" id="mainFiltersBar" role="region" aria-label="Filtros" style="display:none;"></div>

    <div class="summary-wrapper">
      <div class="summary" id="chs-summary">
        <div class="box" id="chsTotal" title="Mostrar todos" onclick="onSummaryClick('all')">Total de Clientes<br><b id="chsTotalVal">--</b></div>
        <div class="box saude" id="chsSaudavel" title="Mostrar clientes SaudÃ¡veis" onclick="onSummaryClick('saude')">SaudÃ¡veis<br><b id="chsSaudavelVal">--</b></div>
        <div class="box atencao" id="chsAtencao" title="Mostrar clientes em AtenÃ§Ã£o" onclick="onSummaryClick('atencao')">AtenÃ§Ã£o<br><b id="chsAtencaoVal">--</b></div>
        <div class="box critico" id="chsCritico" title="Mostrar clientes CrÃ­ticos" onclick="onSummaryClick('critico')">CrÃ­ticos<br><b id="chsCriticoVal">--</b></div>
        <div class="box geral" id="chsGeralBox">
          <div style="font-size:0.95rem;">CHS Geral</div>
          <b id="chsGeralValor" style="font-size:1.2rem;">--</b>
        </div>
      </div>
    </div>

    

    <div id="graficosPrincipais">
      <div class="dashboard-charts-row">
        <div class="dashboard-chart-container">
          <button class="chart-help-btn" data-tip="Mostra quantos clientes estÃ£o em cada faixa de saÃºde (SaudÃ¡vel, AtenÃ§Ã£o e CrÃ­tico) para o filtro/seleÃ§Ã£o atuais.">?</button>
          <button class="chart-toggle-btn" title="Mudar tipo do grÃ¡fico (apenas este grÃ¡fico)" onclick="toggleChartTypeFor('distrib')">ðŸ”</button>
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
          <h3>DistribuiÃ§Ã£o de CHS dos Clientes</h3>
          <div class="chart-wrapper"><canvas id="chartChsDistrib"></canvas></div>
        </div>
        <div class="dashboard-chart-container">
          <button class="chart-help-btn" data-tip="Percentual de clientes que subiram, caÃ­ram ou mantiveram a nota em relaÃ§Ã£o ao mÃªs anterior.">?</button>
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
          <h3>Clientes em alta, queda e neutros (%)</h3>
          <div class="chart-wrapper"><canvas id="chartTrendUp"></canvas></div>
        </div>
        <div class="dashboard-chart-container">
          <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
          <div class="ranking-card-header">
            <h3 id="indicadorTitle">EvoluÃ§Ã£o CHS (por MÃªs)</h3>
            <div class="ranking-order-wrap" id="indicatorFiltersWrap">
              <button class="btn" id="indicatorFiltersBtn" type="button" onclick="toggleIndicatorFiltersMenu()" title="Abrir filtros">Filtros â–¾</button>
              <div class="filters-menu" id="indicatorFiltersMenu" role="menu" aria-hidden="true">
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('nps')">NPS</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('sla')">SLA</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('neg')">Av Negativa</button>
                <div class="separator"></div>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('cs')">PercepÃ§Ã£o CS</button>
                <button class="filters-item" type="button" onclick="applyIndicatorFilter('chs')">CHS</button>
              </div>
            </div>
          </div>
          <div class="chart-wrapper"><canvas id="chartIndicadores"></canvas></div>
        </div>
      </div>
      <!-- Trend chart moved to 'Ver Mais' section -->
    </div>

    

    <div id="graficosIndividuais" class="collapsible expanded" style="display:block;" aria-hidden="false">
      <!-- New indicator charts: SLA, CS, NPS, Negativas (standardized with above) -->
      <div class="dashboard-charts-row"></div>
    </div>

    <div class="dashboard-rankings-row">
      <div class="dashboard-ranking-container" id="rankingPiores">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
        <h3>5 Menores CHS</h3>
        <ul class="dashboard-ranking-list" id="rankingPioresList"></ul>
      </div>
      <div class="dashboard-ranking-container" id="rankingMelhores">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
        <h3>5 Maiores CHS</h3>
        <ul class="dashboard-ranking-list" id="rankingMelhoresList"></ul>
      </div>
      <div class="dashboard-ranking-container ranking-geral" id="rankingGeral">
        <button class="fullscreen-btn" title="Tela cheia" onclick="toggleElementFullscreen(this)">â›¶</button>
        <div class="ranking-card-header">
          <h3>ðŸ† Ranking Geral de Clientes</h3>
          <div class="ranking-order-wrap" id="rankingFiltersWrap">
            <button class="btn" id="rankingFiltersBtn" type="button" onclick="toggleRankingFiltersMenu()" title="Abrir filtros">Filtros â–¾</button>
            <div class="filters-menu" id="rankingFiltersMenu" role="menu" aria-hidden="true">
              <button class="filters-item" type="button" onclick="applyRankingFilter('up')">Em Alta</button>
              <button class="filters-item" type="button" onclick="applyRankingFilter('down')">Em Queda</button>
              <div class="separator"></div>
              <button class="filters-item" type="button" onclick="applyRankingFilter('asc')">Crescente</button>
              <button class="filters-item" type="button" onclick="applyRankingFilter('desc')">Decrescente</button>
            </div>
          </div>
        </div>
        <ul class="dashboard-ranking-list" id="rankingGeralList"></ul>
        <div class="ranking-pagination">
          <button class="btn" id="rankingPrevBtn" type="button" onclick="rankingPrev()" title="PÃ¡gina anterior">â—€</button>
          <span id="rankingPageInfo">1 / 1</span>
          <button class="btn" id="rankingNextBtn" type="button" onclick="rankingNext()" title="PrÃ³xima pÃ¡gina">â–¶</button>
        </div>
      </div>
    </div>

  </div>

  <!-- Floating filters container (will be populated dynamically) -->
  <div id="floatingFilters" class="floating-filters show" aria-hidden="false"></div>

  <!-- Select modal (centered overlay) -->
  <div class="compare-selector-modal" id="selectModal" aria-hidden="true" style="display:none; z-index:12500;">
    <div class="compare-selector-box" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">Selecionar clientes (para anÃ¡lise)</div>
        <div class="modal-controls">
          <button class="btn" onclick="selectAllSelectVisible()">Selecionar todos</button>
          <button class="btn" onclick="clearAllSelectSelection()">Limpar</button>
          <button class="btn" onclick="closeSelectModal()" style="background:#c7c7c7;color:#000;">Fechar</button>
        </div>
      </div>

      <div class="modal-body">
        <div style="flex:1;">
          <input id="selectModalSearch" class="modal-search" placeholder="Buscar nome dentro desta janela..." oninput="renderSelectModalList()" />
          <div style="margin-bottom:8px;color:var(--tryvia-dark2);font-weight:600;">Use o campo acima para filtrar a lista de clientes nesta janela.</div>
          <div class="list-area">
            <div class="compare-selector-list" id="selectModalList" style="display:flex; flex-direction:column; gap:6px; padding:6px;"></div>
          </div>
        </div>

        <div class="info-area" aria-hidden="true">
          <div style="font-weight:800;color:var(--tryvia-cyan);">Resumo</div>
          <div id="selectModalInfo" style="font-size:0.95rem;color:var(--tryvia-dark2);">
            Selecione clientes Ã  esquerda para incluir na anÃ¡lise. Esta Ã¡rea Ã© apenas visual e padronizada com o restante do site.
          </div>
          <div style="margin-top:auto;width:100%;display:flex;gap:8px;">
            <button class="btn btn-primary" style="flex:1" onclick="applySelectSelection()">Aplicar seleÃ§Ã£o</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Compare selector modal (centered overlay) -->
  <div class="compare-selector-modal" id="compareSelectorModal" aria-hidden="true" style="display:none;">
    <div class="compare-selector-box" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">Selecionar clientes para comparaÃ§Ã£o</div>
        <div class="modal-controls">
          <input id="compareModalSearch" class="modal-search" placeholder="Buscar nome aqui..." oninput="renderCompareSelector()" style="width:220px;" />
          <div class="date-field" style="margin-left:6px;">
            <span class="calendar-icon">ðŸ“…</span>
            <select id="compareModalMesSelect" class="client-modal-mes" onchange="renderCompareSelector()" title="Filtrar por mÃªs ao selecionar clientes para comparar">
              <option value="all">MÃªs: Todos</option>
            </select>
          </div>
          <button class="btn" onclick="selectAllCompareVisible()">Selecionar todos</button>
          <button class="btn" onclick="clearAllCompareSelection()">Limpar</button>
          <button class="btn" onclick="closeCompareSelector()" style="background:#c7c7c7;color:#000;">Fechar</button>
        </div>
      </div>

      <div class="modal-body">
        <div style="flex:1;">
          <div style="margin-bottom:8px;color:var(--tryvia-dark2);font-weight:600;">Use o campo acima para filtrar a lista na janela de comparaÃ§Ã£o e escolha o mÃªs para comparar os dados.</div>
          <div class="list-area">
            <div class="compare-selector-list" id="compareSelectorList" style="display:flex; flex-direction:column; gap:6px; padding:6px;"></div>
          </div>
        </div>

        <div class="info-area" aria-hidden="true">
          <div style="font-weight:800;color:var(--tryvia-cyan);">ObservaÃ§Ãµes</div>
          <div style="font-size:0.95rem;color:var(--tryvia-dark2);">
            Escolha pelo menos 2 clientes Ã  esquerda e clique em "Comparar selecionados" para abrir a comparaÃ§Ã£o visual.
          </div>
          <div style="margin-top:auto;width:100%;display:flex;gap:8px;">
            <button class="btn btn-primary" style="flex:1" onclick="applyCompareSelection()">Comparar selecionados</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Compare chart modal -->
  <div class="compare-modal" id="compareModal" role="dialog" aria-hidden="true" style="display:none;">
    <div class="compare-modal-box">
      <div class="modal-header">
        <div class="modal-title" id="compareModalTitle">ComparaÃ§Ã£o de Clientes</div>
        <div class="modal-controls">
          <div class="date-field" style="margin-left:6px;">
            <span class="calendar-icon">ðŸ“…</span>
            <select id="compareModalMesSelectTop" class="client-modal-mes" onchange="rebuildCompareChartFromModal()" title="Filtrar mÃªs da comparaÃ§Ã£o (visualizaÃ§Ã£o)">
              <option value="all">MÃªs: Todos</option>
            </select>
          </div>
          <button class="btn" onclick="closeCompareModal()" style="background:var(--tryvia-red);color:white;">Fechar</button>
        </div>
      </div>

      <div class="modal-body" style="padding-top:6px;">
        <div style="width:100%;height:360px;">
          <canvas id="compareChart" class="compare-modal-canvas"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- Cliente modal (dynamic) - will be shown as centered overlay -->
  <div class="cliente-modal" id="clienteModal" style="display:none;"></div>

<script>
const URL_DA_PLANILHA = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQFJga3Q0ulkeK0xx968BHQHvBnXGA7mg_8lSFa_xc1xBedTI_jU0FVC2yqyEYCG4Pt0J0gP85EMAri/pub?gid=1977027647&single=true&output=csv";
/* Full JS restored and preserved. All functions included to ensure full functionality:
   - parsing/import (colarPlanilha) now expects 12 columns and includes 'agente'
   - selection modals (openSelectModal, renderSelectModalList, etc.)
   - compare modals (openCompareSelector, renderCompareSelector, etc.)
   - charts creation (Chart.js)
   - rankings, table rendering, filters
   - floating filters observer to show floating bar when main bar scrolls out
   - togglePlanilhaBox and setinha behavior
   - client modal open/update/close (abrirClienteModal, updateClienteModal, fecharClienteModal)
   - autocomplete suggestions for "Buscar cliente..." added without changing existing functions.
   - ranking order button and logic (toggleRankingOrder and rankingOrderDesc)
   - new trend filter button (toggleRankingTrend) cycles: all -> down -> up -> all
   - renderRankingGeral now supports trend filtering (only down/up) and uses same delta logic as before
*/

/* Globals */
let clientes = [];
let clientesFiltrados = [];
let currentMes = 'all';
let currentFilter = "all";
  let chartChsDistrib = null, chartChsEvolucao = null, chartCompare = null;
  let chartSlaEvolucao = null, chartCsEvolucao = null, chartNpsEvolucao = null, chartNegEvolucao = null;
  let chartTypeDistrib = 'doughnut', chartTypeEvol = 'line', chartTypeSLA = 'line', chartTypeCS = 'line', chartTypeNPS = 'line', chartTypeNEG = 'line';
  let rankingPage = 1;
  let rankingPageSize = 5;
  let selectedClients = new Set();
let compareSelectedClients = new Set();
let statusFilter = 'all';
let chartClienteDonut = null;
let chartClienteComp = null;
let chartTrendDown = null;
let chartTrendUp = null;
let chartIndicadores = null;
let indicadorAtual = 'chs'; // 'chs' | 'nps' | 'sla' | 'neg' | 'cs'
let chartChsBreakdown = null;
let chartTypeBreakdown = 'bar';
let tvRankingParentOrig = null;
let tvRankingNextSibling = null;
let tvTrendParentOrig = null;
let tvTrendNextSibling = null;
let tvIndParentOrig = null;
let tvIndNextSibling = null;
let tvChsParentOrig = null;
let tvChsNextSibling = null;

// ConfiguraÃ§Ã£o global de CHS (thresholds e pesos)
const CHS_CONFIG = {
  thresholds: { saude: 70, atencao: 40 }, // critico < atencao; atencao <= x < saude; saude >=
  weights: { // pesos relativos (serÃ£o normalizados)
    cs: 0.25,
    nps: 0.25,
    sla: 0.30,
    neg: 0.20
  },
  useFormulaOverride: false // quando true, recalcula cli.chs com base nos pesos
};

function normalizeWeights(obj){ const t = Object.values(obj||{}).reduce((a,b)=>a+(+b||0),0)||1; const out={}; for(const k in obj) out[k]=(obj[k]||0)/t; return out; }
function computeSlaPct(cli){
  const t1=Number(cli.sla1ok)||0,f1=Number(cli.sla1off)||0,t2=Number(cli.sla2ok)||0,f2=Number(cli.sla2off)||0;
  const p1=(t1+f1)>0 ? (t1/(t1+f1))*100 : null;
  const p2=(t2+f2)>0 ? (t2/(t2+f2))*100 : null;
  if(p1!=null && p2!=null) return (p1+p2)/2; if(p1!=null) return p1; if(p2!=null) return p2; return null;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function to0_100(x,min,max){ if(x==null||isNaN(x)) return null; if(min==null||max==null||max===min) return Math.max(0, Math.min(100, Number(x))); const v=(x-min)/(max-min); return Math.round(clamp01(v)*100); }

// NormalizaÃ§Ã£o simples: cs (0-10), nps (-100 a 100), neg (0-100 menor Ã© melhor), sla (jÃ¡ %)
function normalizeMetrics(cli){
  const cs = to0_100(Number(cli.cs), 0, 10);
  const nps = to0_100(Number(cli.nps), -100, 100);
  const negRaw = Number(cli.neg); // % de avaliaÃ§Ãµes negativas
  const neg = (isNaN(negRaw) ? null : Math.round((1 - clamp01(negRaw/100))*100)); // maior melhor
  const slaPct = computeSlaPct(cli);
  const sla = (slaPct==null?null:Math.round(slaPct));
  return { cs, nps, neg, sla };
}

function calculateChsFromComponents(cli){
  const w = normalizeWeights(CHS_CONFIG.weights);
  const { cs, nps, neg, sla } = normalizeMetrics(cli);
  const parts = [];
  if(cs!=null) parts.push(w.cs*cs); if(nps!=null) parts.push(w.nps*nps); if(neg!=null) parts.push(w.neg*neg); if(sla!=null) parts.push(w.sla*sla);
  if(!parts.length) return cli.chs||0;
  return Math.round(parts.reduce((a,b)=>a+b,0));
}

function recalculateAllChs(){
  if(!CHS_CONFIG.useFormulaOverride) return;
  (clientes||[]).forEach(cli=>{ cli.chs = calculateChsFromComponents(cli); });
}

function setChsConfig(cfg){ Object.assign(CHS_CONFIG, cfg||{}); recalculateAllChs(); try{ refreshAll(); }catch(e){} }

const ValueLabelsAll = {
  id: 'valueLabelsAll',
  afterDatasetsDraw(chart, args, pluginOptions) {
    try{
      if (!chart) return;
      if (pluginOptions === false || (pluginOptions && pluginOptions.enabled === false)) return;
      const ctx = chart.ctx;
      const type = (chart.config && chart.config.type) || '';
      const datasets = (chart.data && chart.data.datasets) || [];
      const offset = (pluginOptions && pluginOptions.offset) || 6;
      const color = (pluginOptions && pluginOptions.color) || '#111';
      const font = (pluginOptions && pluginOptions.font) || 'bold 12px Roboto, Arial, sans-serif';
      ctx.save();
      ctx.fillStyle = color;
      ctx.font = font;

      if(type === 'bar'){
        const isHorizontal = chart.options && chart.options.indexAxis === 'y';
        datasets.forEach((ds, di) => {
          if(ds && ds.hidden) return;
          const meta = chart.getDatasetMeta(di);
          (meta?.data || []).forEach((elem, i) => {
            const v = ds?.data?.[i];
            if (v == null) return;
            const text = (typeof v === 'number') ? (Math.round(v*10)/10).toString() : String(v);
            const p = elem.tooltipPosition();
            if (isHorizontal) {
              ctx.textAlign = 'left';
              ctx.textBaseline = 'middle';
              try{ ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x + offset, p.y); }catch(e){}
              ctx.fillText(text, p.x + offset, p.y);
            } else {
              ctx.textAlign = 'center';
              ctx.textBaseline = 'bottom';
              try{ ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y - offset); }catch(e){}
              ctx.fillText(text, p.x, p.y - offset);
            }
          });
        });
      } else if(type === 'line'){
        datasets.forEach((ds, di) => {
          if(ds && ds.hidden) return;
          const meta = chart.getDatasetMeta(di);
          (meta?.data || []).forEach((elem, i) => {
            const v = ds?.data?.[i];
            if(v == null) return;
            const text = (typeof v === 'number') ? (Math.round(v*10)/10).toString() : String(v);
            const p = elem.tooltipPosition();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            try{ ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y - 6); }catch(e){}
            ctx.fillText(text, p.x, p.y - 6);
          });
        });
      } else if(type === 'doughnut' || type === 'pie'){
        datasets.forEach((ds, di) => {
          if(ds && ds.hidden) return;
          const meta = chart.getDatasetMeta(di);
          (meta?.data || []).forEach((elem, i) => {
            const v = ds?.data?.[i];
            if(v == null || v === 0) return;
            const text = (typeof v === 'number') ? (Math.round(v*10)/10).toString() : String(v);
            const p = elem.tooltipPosition();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            try{ ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.strokeText(text, p.x, p.y); }catch(e){}
            ctx.fillText(text, p.x, p.y);
          });
        });
      }

      ctx.restore();
    }catch(e){}
  }
};
try { Chart.register(ValueLabelsAll); } catch(e) {}
/* Plugin: draw a background grid behind doughnut for DistribuiÃ§Ã£o chart */
const DoughnutGridBG = {
  id: 'doughnutGridBG',
  beforeDatasetsDraw(chart, args, opts){
    try{
      if(!chart || chart.config?.type !== 'doughnut') return;
      const id = chart?.canvas?.id || '';
      if(id !== 'chartChsDistrib') return;
      const {ctx, chartArea} = chart; if(!chartArea) return;
      const {left, right, top, bottom, width, height} = chartArea;
      ctx.save();
      ctx.strokeStyle = '#e9eef3';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 4]);
      // vertical lines
      const vLines = 6; for(let i=1;i<vLines;i++){ const x = left + (width*i/vLines); ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, bottom); ctx.stroke(); }
      // horizontal lines
      const hLines = 4; for(let j=1;j<hLines;j++){ const y = top + (height*j/hLines); ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke(); }
      ctx.restore();
    }catch(e){}
  }
};
/* Plugin: draw a horizontal target line (e.g., y=70) on charts with a y-scale */
const TargetLine = {
  id: 'targetLine',
  afterDatasetsDraw(chart, args, opts){
    try{
      if(!chart || !chart.scales || !chart.scales.y) return;
      // draw ONLY when explicitly configured on the chart options
      if(!(opts && (typeof opts.y === 'number' || opts.enabled === true))) return;
      const yValue = (opts && typeof opts.y === 'number') ? opts.y : 70;
      const color = (opts && opts.color) || '#666';
      const width = (opts && opts.width) || 2;
      const dash = (opts && opts.dash) || [6,4];
      const y = chart.scales.y.getPixelForValue(yValue);
      const {left, right} = chart.chartArea || {};
      if(!(left>=0 && right>left && isFinite(y))) return;
      const ctx = chart.ctx; ctx.save();
      ctx.beginPath(); ctx.setLineDash(dash); ctx.lineWidth = width; ctx.strokeStyle = color; ctx.moveTo(left, y); ctx.lineTo(right, y); ctx.stroke(); ctx.restore();
    }catch(e){}
  }
};
/* Plugin: center text inside doughnut (used only on clienteChartDonut) */
const CenterText = {
  id: 'centerText',
  afterDraw(chart, args, opts){
    try{
      if(!opts || opts.enabled === false) return;
      if(chart.config?.type !== 'doughnut') return;
      const {ctx, chartArea} = chart; if(!ctx || !chartArea) return;
      const text = (typeof opts.text === 'function') ? opts.text(chart) : (opts.text || '');
      if(!text) return;
      const cx = (chartArea.left + chartArea.right) / 2;
      const cy = (chartArea.top + chartArea.bottom) / 2;
      ctx.save();
      ctx.fillStyle = opts.color || '#000';
      ctx.font = opts.font || '900 28px Roboto, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      try{ ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.strokeText(text, cx, cy); }catch(e){}
      ctx.fillText(text, cx, cy);
      ctx.restore();
    }catch(e){}
  }
};
try{ Chart.register(DoughnutGridBG, TargetLine, CenterText); }catch(e){}
try {
  Chart.defaults.animation = Object.assign({}, Chart.defaults.animation, { duration: 500, easing: 'easeOutQuart' });
  if(Chart.defaults.transitions && Chart.defaults.transitions.active && Chart.defaults.transitions.active.animation){
    Chart.defaults.transitions.active.animation.duration = 400;
  }
} catch(e) {}

/* Smoothly reveal a chart canvas by id (fade + slight slide) */
function animateChartRender(canvasId){
  try{
    const el = document.getElementById(canvasId);
    if(!el) return;
    const wrap = el.closest('.chart-wrapper') || el;
    wrap.classList.add('chart-anim','fade-in','slide-up-in');
    setTimeout(function(){ wrap.classList.remove('fade-in','slide-up-in'); }, 320);
  }catch(e){}
}

/* Body scroll lock helpers to avoid layout shift when overlay opens */
function lockBodyScroll(){
  try{
    if(document.body.dataset.scrollLocked === '1') return;
    const pr = window.innerWidth - document.documentElement.clientWidth;
    document.body.style.overflow = 'hidden';
    if(pr > 0){ document.body.style.paddingRight = pr + 'px'; }
    document.body.dataset.scrollLocked = '1';
  }catch(e){}
}
function unlockBodyScroll(){
  try{
    document.body.style.overflow = '';
    document.body.style.paddingRight = '';
    delete document.body.dataset.scrollLocked;
  }catch(e){}
}

/* New: ranking order state variable (true = descending, false = ascending) */
let rankingOrderDesc = true;

/* New: ranking trend filter state: 'all' | 'down' | 'up' */
let rankingTrendState = 'all'; // default show all

/* Component maximum scores for display */
const MAX_SLA = 20;
const MAX_NPS = 30;
const MAX_NEG = 30;
const MAX_CS  = 20;

/* Calculation helpers */
function calcSLA(cli){
  let sla1ok=Number(cli.sla1ok),sla1off=Number(cli.sla1off),sla2ok=Number(cli.sla2ok),sla2off=Number(cli.sla2off);
  if((isNaN(sla1ok)||isNaN(sla1off)||isNaN(sla2ok)||isNaN(sla2off))||(sla1ok+sla1off===0)||(sla2ok+sla2off===0)) return 0;
  let pct1=sla1ok/(sla1ok+sla1off),pct2=sla2ok/(sla2ok+sla2off),slaMedia=(pct1+pct2)/2;
  if(slaMedia>=1)return 20; if(slaMedia>=0.9)return 15; if(slaMedia>=0.8)return 10; if(slaMedia>=0.7)return 5; return 0;
}
function calcNPS(cli,mediaNps=6){ let nps=cli.nps; if(nps===null||nps===""||isNaN(Number(nps))) nps=mediaNps; nps=Math.round(Number(nps)); if(nps>=9) return 30; if(nps===8) return 22; if(nps===7) return 14; if(nps===6) return 7; if(nps===5) return 2; return 0; }
function calcNeg(cli){ let neg=Number(cli.neg); if(isNaN(neg)) return 0; neg=Math.round(neg); if(neg===0) return 30; if(neg===1) return 15; if(neg===2) return 5; if(neg>=3) return 0; return 0; }
function calcCS(cli,mediaCs=5){ let cs=cli.cs; if(cs===null||cs===""||isNaN(Number(cs))) cs=mediaCs; cs=Math.round(Number(cs)); if(cs>=10) return 20; if(cs===9) return 16; if(cs===8) return 12; if(cs===7) return 8; if(cs===6) return 4; if(cs<=5) return 0; return 0; }
function calcMedia(list,fieldFn){ let vals=list.map(fieldFn).filter(v=>v!=null&&v!==""&&!isNaN(v)); if(!vals.length) return 0; return Math.round(vals.reduce((a,b)=>a+Number(b),0)/vals.length); }
function calcCHS(cli,clientesList){ let mediaNPS=calcMedia(clientesList,c=>c.nps),mediaCS=calcMedia(clientesList,c=>c.cs); return Number(calcSLA(cli))+Number(calcNPS(cli,mediaNPS))+Number(calcNeg(cli))+Number(calcCS(cli,mediaCS)); }

/* UPDATED thresholds and status mapping to match requested ranges:
   SaudÃ¡vel: 100 - 70  (>= 70)
   AtenÃ§Ã£o: 69 - 40    (>= 40 && < 70)
   CrÃ­tico: 39 - 0     (< 40)
*/
function getStatusCHS(chs){
  if (isNaN(Number(chs))) return {txt: "Indefinido", cls: "critico", cor: "#e53935"};
  const v = Number(chs);
  if(v >= 70) return {txt:"SaudÃ¡vel",cls:"saude",cor:"#009f42"};
  if(v >= 40) return {txt:"AtenÃ§Ã£o",cls:"atencao",cor:"#ffc900"};
  return {txt:"CrÃ­tico",cls:"critico",cor:"#e53935"};
}
function formatMesAno(ym){ if(!ym) return ""; let [y,m]=ym.split('-'); return `${m}/${y}`; }
function normalizeYYYYMM(s){
  if(!s) return "";
  const str = String(s).trim();
  // 1) YYYY-MM or YYYY/MM or YYYYMM (optionally with day at the end)
  let m = str.match(/^(\d{4})[-\/]?(\d{1,2})(?:[-\/]\d{1,2})?$/);
  if(m){
    const y = m[1];
    const mm = m[2].padStart(2,'0');
    return `${y}-${mm}`;
  }
  // 2) DD/MM/YYYY or D/M/YYYY (take middle as month)
  m = str.match(/^(\d{1,2})[-\/]?(\d{1,2})[-\/]?(\d{2,4})$/);
  if(m){
    const y = m[3].length === 2 ? (m[3] > '50' ? '19'+m[3] : '20'+m[3]) : m[3];
    const mm = m[2].padStart(2,'0');
    return `${y}-${mm}`;
  }
  // 3) MM/YYYY or M/YYYY
  m = str.match(/^(\d{1,2})[-\/]?(\d{4})$/);
  if(m){
    const y = m[2];
    const mm = m[1].padStart(2,'0');
    return `${y}-${mm}`;
  }
  // Do NOT try to infer from arbitrary digits (prevents phantom months from telefone/IDs)
  return "";
}
function preparaClientes(list){ list.forEach(cli=>{ cli.nome = (cli.nome || '').toString().trim(); cli.chs=calcCHS(cli,list); cli.status=getStatusCHS(cli.chs).txt; cli.dataFmt = normalizeYYYYMM(cli.data); }); }
function escapeHtml(str){ if(!str && str!==0) return ""; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

/* Aggregate by name (now includes agente) */
function aggregateByName(list){
  const map = {};
  (list||[]).forEach(c=>{
    const name = c.nome;
    if(!map[name]) map[name] = {count:0, chsSum:0, csSum:0, npsSum:0, negSum:0, sla1okSum:0, sla1offSum:0, sla2okSum:0, sla2offSum:0, gestor:c.gestor||"", celular:c.celular||"", agente:c.agente||""};
    map[name].count++;
    map[name].chsSum += Number(c.chs)||0;
    map[name].csSum += isNaN(Number(c.cs))?0:Number(c.cs);
    map[name].npsSum += isNaN(Number(c.nps))?0:Number(c.nps);
    map[name].negSum += isNaN(Number(c.neg))?0:Number(c.neg);
    map[name].sla1okSum += Number(c.sla1ok)||0;
    map[name].sla1offSum += Number(c.sla1off)||0;
    map[name].sla2okSum += Number(c.sla2ok)||0;
    map[name].sla2offSum += Number(c.sla2off)||0;
  });
  return Object.keys(map).map(name=>{
    const m = map[name];
    const cnt = m.count || 1;
    return {
      nome: name,
      chs: Math.round(m.chsSum / cnt),
      cs: Math.round(m.csSum / cnt),
      nps: Math.round(m.npsSum / cnt),
      neg: Math.round(m.negSum / cnt),
      sla1ok: Math.round(m.sla1okSum / cnt),
      sla1off: Math.round(m.sla1offSum / cnt),
      sla2ok: Math.round(m.sla2okSum / cnt),
      sla2off: Math.round(m.sla2offSum / cnt),
      gestor: m.gestor,
      celular: m.celular,
      agente: m.agente
    };
  });
}

/* Gradient helpers */
function redGradientForCHS(chs){
  const c = Math.max(0, Math.min(100, Number(chs) || 0));
  const intensity = Math.max(0, Math.min(1, (60 - c) / 60));
  const light = Math.round(56 - intensity * 20);
  const dark = Math.max(12, light - 18);
  const color1 = `hsl(0,85%,${light}%)`;
  const color2 = `hsl(0,75%,${dark}%)`;
  return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
}
function greenGradientForCHS(chs){
  const c = Math.max(0, Math.min(100, Number(chs) || 0));
  const intensity = c / 100;
  const light = Math.round(66 - intensity * 32);
  const dark = Math.max(16, light - 24);
  const color1 = `hsl(140,60%,${light}%)`;
  const color2 = `hsl(140,70%,${dark}%)`;
  return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
}
function yellowGradientForCHS(chs){
  const c = Math.max(0, Math.min(100, Number(chs) || 0));
  const intensity = c / 100;
  const light = Math.round(70 - intensity * 20);
  const dark = Math.max(20, light - 22);
  const color1 = `hsl(45,95%,${light}%)`;
  const color2 = `hsl(45,90%,${dark}%)`;
  return `linear-gradient(180deg, ${color1} 0%, ${color2} 100%)`;
}

/* ---------------- Selection modal (main) ---------------- */

function openSelectModal(){
  renderSelectModalList();
  const m = document.getElementById('selectModal');
  m.style.display = 'flex';
  m.setAttribute('aria-hidden','false');
  lockBodyScroll();
  m.classList.remove('fade-out');
  m.classList.add('fade-in');
  const box = m.querySelector('.compare-selector-box');
  if(box){ box.classList.add('scale-in'); setTimeout(function(){ box.classList.remove('scale-in'); }, 280); }
  const onEndOpen = function(){ if(m.classList.contains('fade-in')) m.classList.remove('fade-in'); m.removeEventListener('animationend', onEndOpen); };
  m.addEventListener('animationend', onEndOpen);
  setTimeout(function(){ const s = document.getElementById('selectModalSearch'); if(s) s.focus(); },50);
}

function closeSelectModal(){
  const m = document.getElementById('selectModal');
  const box = m.querySelector('.compare-selector-box');
  m.classList.remove('fade-in');
  m.classList.add('fade-out');
  if(box){ box.classList.add('slide-down-out'); }
  const onEnd = function(){
    m.style.display = 'none';
    m.setAttribute('aria-hidden','true');
    unlockBodyScroll();
    m.classList.remove('fade-out');
    if(box){ box.classList.remove('slide-down-out'); }
    m.removeEventListener('animationend', onEnd);
  };
  m.addEventListener('animationend', onEnd);
}

function renderSelectModalList(){
  const listEl = document.getElementById('selectModalList');
  if(!listEl) return;
  listEl.innerHTML = '';
  const term = (document.getElementById('selectModalSearch')?.value || '').toLowerCase().trim();
  let base = clientes || [];
  if(currentMes && currentMes !== 'all') base = base.filter(c => c.dataFmt === currentMes);
  const names = Array.from(new Set(base.map(c=>c.nome))).filter(n => !term || n.toLowerCase().includes(term)).sort((a,b)=>a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
  if(names.length === 0){
    const p = document.createElement('div'); p.style.color='var(--tryvia-dark2)'; p.style.fontWeight='700'; p.style.padding='8px'; p.textContent='Nenhum cliente disponÃ­vel.'; listEl.appendChild(p); return;
  }
  names.forEach(name=>{
    const id = 'sel_' + Math.random().toString(36).substr(2,9);
    const checked = selectedClients.has(name) ? 'checked' : '';
    const div = document.createElement('div');
    div.className = 'compare-selector-item';
    div.tabIndex = 0;
    div.innerHTML = `<input type="checkbox" id="${id}" data-name="${escapeHtml(name)}" ${checked} onchange="onSelectModalCheckboxChange(this)" /> <span class="client-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span> <span class="chs-badge">${getAverageCHSForName(name)}</span>`;
    const input = div.querySelector('input');
    div.addEventListener('click', (e)=>{ if(e.target && e.target.tagName !== 'INPUT'){ input.checked = !input.checked; onSelectModalCheckboxChange(input); } });
    div.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); input.checked = !input.checked; onSelectModalCheckboxChange(input); } });
    listEl.appendChild(div);
  });
}

function onSelectModalCheckboxChange(el){
  const name = el.getAttribute('data-name');
  if(!name) return;
  if(el.checked) selectedClients.add(name);
  else selectedClients.delete(name);
}

function selectAllSelectVisible(){
  document.querySelectorAll('#selectModalList input[type="checkbox"]').forEach(ch => {
    ch.checked = true;
    const n = ch.getAttribute('data-name');
    if(n) selectedClients.add(n);
  });
}

function clearAllSelectSelection(){
  document.querySelectorAll('#selectModalList input[type="checkbox"]').forEach(ch => {
    ch.checked = false;
    const n = ch.getAttribute('data-name');
    if(n) selectedClients.delete(n);
  });
}

function applySelectSelection(){
  renderDashboard();
  // Update search inputs to reflect selection count
  try{ updateSelectedClientsInputLabel(); }catch(e){}
  closeSelectModal();
}

/* ---------------- Compare selector ---------------- */

function openCompareSelector(){
  compareSelectedClients = new Set();
  populateCompareMonthSelects();
  renderCompareSelector();
  const m = document.getElementById('compareSelectorModal');
  m.style.display = 'flex';
  m.setAttribute('aria-hidden','false');
  lockBodyScroll();
  m.classList.remove('fade-out');
  m.classList.add('fade-in');
  const box = m.querySelector('.compare-selector-box');
  if(box){ box.classList.add('scale-in'); setTimeout(function(){ box.classList.remove('scale-in'); }, 280); }
  const onEndOpen = function(){ if(m.classList.contains('fade-in')) m.classList.remove('fade-in'); m.removeEventListener('animationend', onEndOpen); };
  m.addEventListener('animationend', onEndOpen);
  setTimeout(function(){ const s = document.getElementById('compareModalSearch'); if(s) s.focus(); },50);
}

function closeCompareSelector(){
  const m = document.getElementById('compareSelectorModal');
  const box = m.querySelector('.compare-selector-box');
  m.classList.remove('fade-in');
  m.classList.add('fade-out');
  if(box){ box.classList.add('slide-down-out'); }
  const onEnd = function(){
    m.style.display = 'none';
    m.setAttribute('aria-hidden','true');
    document.body.style.overflow = '';
    m.classList.remove('fade-out');
    if(box){ box.classList.remove('slide-down-out'); }
    m.removeEventListener('animationend', onEnd);
  };
  m.addEventListener('animationend', onEnd);
}

function renderCompareSelector(){
  const listEl = document.getElementById('compareSelectorList');
  if(!listEl) return;
  listEl.innerHTML = '';
  const term = (document.getElementById('compareModalSearch')?.value || '').toLowerCase().trim();
  let base = clientes || [];
  const selMonth = document.getElementById('compareModalMesSelect')?.value || 'all';
  if(selMonth && selMonth !== 'all') base = base.filter(c => c.dataFmt === selMonth);
  const names = Array.from(new Set(base.map(c=>c.nome))).filter(n => !term || n.toLowerCase().includes(term)).sort((a,b)=>a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
  if(names.length === 0){
    const p = document.createElement('div'); p.style.color='var(--tryvia-dark2)'; p.style.fontWeight='700'; p.style.padding='8px'; p.textContent='Nenhum cliente disponÃ­vel para comparar.'; listEl.appendChild(p); return;
  }
  names.forEach(name=>{
    const id = 'cmp_' + Math.random().toString(36).substr(2,9);
    const div = document.createElement('div');
    div.className = 'compare-selector-item';
    div.tabIndex = 0;
    div.innerHTML = `<input type="checkbox" id="${id}" data-name="${escapeHtml(name)}" onchange="onCompareCheckboxChange(this)" /> <span class="client-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span> <span class="chs-badge">${getAverageCHSForName(name)}</span>`;
    listEl.appendChild(div);
  });
}

function onCompareCheckboxChange(el){
  const name = el.getAttribute('data-name');
  if(!name) return;
  if(el.checked) compareSelectedClients.add(name);
  else compareSelectedClients.delete(name);
}

function selectAllCompareVisible(){
  document.querySelectorAll('#compareSelectorList input[type="checkbox"]').forEach(ch => {
    ch.checked = true;
    const n = ch.getAttribute('data-name');
    if(n) compareSelectedClients.add(n);
  });
}

function clearAllCompareSelection(){
  document.querySelectorAll('#compareSelectorList input[type="checkbox"]').forEach(ch => {
    ch.checked = false;
    const n = ch.getAttribute('data-name');
    if(n) compareSelectedClients.delete(n);
  });
}

function applyCompareSelection(){
  const names = Array.from(compareSelectedClients);
  if(names.length < 2){
    alert('Selecione pelo menos 2 clientes para comparar.');
    return;
  }
  const selMonth = document.getElementById('compareModalMesSelect')?.value || 'all';
  buildCompareChart(names, selMonth);
  closeCompareSelector();
}

/* Build compare chart (now accepts optional month) */
function buildCompareChart(names, month='all'){
  const palette = ['#00cfff','#009f42','#ffc900','#e53935','#0b63b7','#b86bff','#ff8a65'];
  const labels = ['SLA','NPS','Negativas','CS'];
  const datasets = [];
  names.forEach((name, idx) => {
    const clienteAgg = getAggregatedClientDataByNameAndMonth(name, month) || aggregateByName(clientes || []).find(c => c.nome === name) || clientes.find(c=>c.nome===name);
    if(!clienteAgg) return;
    const slaScore = calcSLA(clienteAgg);
    const npsScore = calcNPS(clienteAgg, clienteAgg.nps);
    const negScore = calcNeg(clienteAgg);
    const csScore = calcCS(clienteAgg, clienteAgg.cs);
    datasets.push({
      label: name,
      data: [slaScore, npsScore, negScore, csScore],
      backgroundColor: palette[idx % palette.length],
      borderColor: palette[idx % palette.length],
      borderWidth: 1,
      barPercentage: 0.95,
      categoryPercentage: 0.9,
      maxBarThickness: 44,
      borderRadius: 12,
      borderSkipped: 'bottom'
    });
  });

  const modal = document.getElementById('compareModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden','false');
  lockBodyScroll();
  window.scrollTo({top:0,left:0,behavior:'auto'});
  modal.classList.remove('fade-out');
  modal.classList.add('fade-in');
  try{ const box = modal.querySelector('.compare-modal-box'); if(box){ box.classList.add('scale-in'); setTimeout(function(){ box.classList.remove('scale-in'); }, 280); } }catch(e){}
  const onEndOpen = function(){ if(modal.classList.contains('fade-in')) modal.classList.remove('fade-in'); modal.removeEventListener('animationend', onEndOpen); };
  modal.addEventListener('animationend', onEndOpen);

  const topSelect = document.getElementById('compareModalMesSelectTop');
  if(topSelect) topSelect.value = month || 'all';
  modal._lastCompareNames = names;
  modal._lastCompareMonth = month;

  const ctx = document.getElementById('compareChart').getContext('2d');
  if(chartCompare) chartCompare.destroy();
  chartCompare = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ position:'bottom' } }, scales:{ y:{ beginAtZero:true, max:60 } } }
  });
  try { animateChartRender('compareChart'); } catch(e){}
}

function rebuildCompareChartFromModal(){
  const modal = document.getElementById('compareModal');
  if(!modal || !modal._lastCompareNames) return;
  const names = modal._lastCompareNames;
  const month = document.getElementById('compareModalMesSelectTop')?.value || 'all';
  buildCompareChart(names, month);
}

function closeCompareModal(){
  const modal = document.getElementById('compareModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden','true');
  document.body.style.overflow = '';
  try{ if(chartCompare) chartCompare.destroy(); } catch(e){}
}

/* ---------- existing behaviors (import, charts, rankings, client modal) ---------- */

function togglePlanilhaBox() {
  const box = document.getElementById('planilhaBox');
  const btn = document.getElementById('planilhaToggleBtn');
  if (!box) return;
  if (box.classList.contains('show')) { box.classList.remove('show'); if(btn) btn.textContent = 'â–¾'; }
  else { box.classList.add('show'); if(btn) btn.textContent = 'â–´'; }
}

/* Import function */
function toNumberSafe(val){
  if(val===null || val===undefined) return NaN;
  const s = String(val).replace(/%/g,'').replace(/,/g,'.').replace(/[^0-9.\-]/g,'').trim();
  if(!s) return NaN;
  const n = parseFloat(s);
  return isNaN(n) ? NaN : n;
}
function parseCsvLine(line){
  const out=[]; let cur=""; let inQ=false; for(let i=0;i<line.length;i++){ const ch=line[i]; if(inQ){ if(ch==='"'){ if(line[i+1]==='"'){ cur+='"'; i++; } else { inQ=false; } } else { cur+=ch; } } else { if(ch==='"'){ inQ=true; } else if(ch===','){ out.push(cur.trim()); cur=''; } else { cur+=ch; } } } out.push(cur.trim()); return out; }
function detectCsvDelim(sample){
  const s = String(sample||'');
  const count = (ch)=> (s.match(new RegExp(ch,'g'))||[]).length;
  const commas = count(',');
  const semis = count(';');
  const tabs = (s.match(/\t/g)||[]).length;
  if(semis > commas && semis >= tabs) return ';';
  if(tabs > commas && tabs >= semis) return '\t';
  return ',';
}
function parseCsvLineWithDelim(line, delim){
  const out=[]; let cur=""; let inQ=false; const d = delim || ',';
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(inQ){
      if(ch==='"'){
        if(line[i+1]==='"'){ cur+='"'; i++; }
        else { inQ=false; }
      } else { cur+=ch; }
    } else {
      if(ch==='"'){ inQ=true; }
      else if(ch===d){ out.push(cur.trim()); cur=''; }
      else { cur+=ch; }
    }
  }
  out.push(cur.trim());
  return out;
}
// FunÃ§Ã£o para carregar dados automaticamente
function carregarDoGoogleSheets() {
  try{ console.log("Carregando dados do Google Sheets..."); }catch(e){}
  fetch(URL_DA_PLANILHA)
    .then(response => response.text())
    .then(textoCSV => processarCSV(textoCSV))
    .catch(erro => {
      try{ console.error(erro); }catch(e){}
      alert("Erro ao carregar os dados. Verifique a conexÃ£o.");
    });
}

// FunÃ§Ã£o para ler o CSV do Google
function processarCSV(texto) {
  try{
    let linhas = (texto||'').split(/\r?\n/).filter(l => l.trim());
    let importados = [];
    if(linhas.length === 0) throw new Error('CSV vazio');
    const delim = detectCsvDelim(linhas[0]||'');

    // Helpers
    const toNum = (v)=> toNumberSafe(v);
    const byHeader = ()=>{
      const out=[];
      // Parse header and build index map by names
      const normalizeHeader = (s)=>{
        let t = String(s||'');
        try{
          if(/[Ã‚Ãƒ]/.test(t)){
            // tenta corrigir mojibake ISO-8859-1 -> UTF-8
            t = decodeURIComponent(escape(t));
          }
        }catch(e){}
        t = t.toLowerCase();
        // normaliza ordinais comuns e sÃ­mbolos esquisitos
        t = t.replace(/[Âª]/g,'a').replace(/[ÂºÂ°]/g,'o');
        // remove pontuaÃ§Ã£o comum
        t = t.replace(/[.,;:!?"'`Â´^~@#$%&*()_+=\\\/\[\]|{}<>-]+/g,' ');
        // remove acentos
        t = t.normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        // colapsa espaÃ§os
        t = t.replace(/\s+/g,' ').trim();
        return t;
      };
      const headerCols = parseCsvLineWithDelim(linhas[0]||'', delim).map(c=>c!=null?String(c).trim():"");
      const hnorm = headerCols.map(normalizeHeader);
      const findIdx = (aliases)=>{ for(const a of aliases){ const idx = hnorm.indexOf(a); if(idx!==-1) return idx; } return -1; };
      const idxNome   = findIdx(['cliente','nome','cliente empresa','empresa']);
      const idxData   = findIdx(['data','mes','m\u00eas','mÃªs']);
      const idxCS     = findIdx(['percepcao cs','percepcao','percepcao do cliente','percepcao cliente','percep\u00e7ao cs','percepÃ§Ã£o cs','cs']);
      const idxNPS    = findIdx(['nps rate','nps','nps medio','nps m\u00e9dio']);
      const idxNEG    = findIdx(['av neg fresh','av neg','negativas','avaliacoes negativas','avalia\u00e7oes negativas','avaliacao negativa','avalia\u00e7ao negativa','neg']);
      const idxS1ok   = findIdx(['1a resposta dentro sla','1 a resposta dentro sla','1 resposta dentro sla','primeira resposta dentro sla','primeira resposta ok']);
      const idxS1off  = findIdx(['1a resposta fora sla','1 a resposta fora sla','1 resposta fora sla','primeira resposta fora sla']);
      const idxS2ok   = findIdx(['resolucao sla ok','resolucao dentro sla','resolucao ok','resolu\u00e7ao sla ok','resolu\u00e7ao dentro sla','resolu\u00e7\u00e3o sla ok','resoluÃ§Ã£o sla ok']);
      const idxS2off  = findIdx(['resolucao off sla','resolucao fora sla','resolucao off-sla','resolucao offsla','resolu\u00e7ao off sla','resoluÃ§Ã£o off sla','resolucao fora do sla','resoluÃ§Ã£o fora do sla','resolucao off']);
      const idxGestor = findIdx(['gestor','responsavel','respons\u00e1vel','manager']);
      const idxCel    = findIdx(['celular','telefone','phone','whatsapp','contato']);
      const idxAgente = findIdx(['agente','atendente','analista']);

      const hasHeader = (idxNome>=0 && idxData>=0);
      const inicio = hasHeader ? 1 : 0;
      for (let i = inicio; i < linhas.length; i++) {
        let colunas = parseCsvLineWithDelim(linhas[i], delim); if (!colunas) continue; colunas = colunas.map(c => c != null ? String(c).trim() : ""); if (colunas.length === 0) continue;
        const nome  = hasHeader ? (idxNome>=0 ? colunas[idxNome] : '') : (colunas[0]||'');
        const data  = hasHeader ? (idxData>=0 ? colunas[idxData] : '') : (colunas[1]||'');
        const cs    = hasHeader ? (idxCS>=0   ? colunas[idxCS]   : '') : (colunas[2]||'');
        const nps   = hasHeader ? (idxNPS>=0  ? colunas[idxNPS]  : '') : (colunas[3]||'');
        const neg   = hasHeader ? (idxNEG>=0  ? colunas[idxNEG]  : '') : (colunas[4]||'');
        const sla1ok  = hasHeader ? (idxS1ok>=0 ? colunas[idxS1ok] : '') : (colunas[5]||'');
        const sla1off = hasHeader ? (idxS1off>=0? colunas[idxS1off]: '') : (colunas[6]||'');
        const sla2ok  = hasHeader ? (idxS2ok>=0 ? colunas[idxS2ok] : '') : (colunas[7]||'');
        const sla2off = hasHeader ? (idxS2off>=0? colunas[idxS2off]: '') : (colunas[8]||'');
        const gestor  = hasHeader ? (idxGestor>=0? colunas[idxGestor]: '') : (colunas[9]||'');
        const celular = hasHeader ? (idxCel>=0   ? colunas[idxCel]   : '') : (colunas[10]||'');
        const agente  = hasHeader ? (idxAgente>=0? colunas[idxAgente]: '') : (colunas[11]||'');
        if (!nome) continue;
        const dataFmt = normalizeYYYYMM(data); if(!data || !dataFmt) continue;
        out.push({ nome, data, dataFmt, cs: toNum(cs), nps: toNum(nps), neg: toNum(neg), sla1ok: Number(sla1ok||0), sla1off: Number(sla1off||0), sla2ok: Number(sla2ok||0), sla2off: Number(sla2off||0), gestor: gestor||"", celular: celular||"", agente: agente||"" });
      }
      return out;
    };
    const byPosition = ()=>{
      const out=[]; const inicio= (/(cliente|nome)/i.test(linhas[0]||'')) ? 1 : 0;
      for (let i=inicio;i<linhas.length;i++){
        let colunas = parseCsvLineWithDelim(linhas[i], delim); if(!colunas) continue; colunas = colunas.map(c=>c!=null?String(c).trim():""); if(colunas.length<2) continue;
        const [nome,data,cs,nps,neg,sla1ok,sla1off,sla2ok,sla2off,gestor,celular,agente] = colunas;
        if(!nome) continue; const dataFmt=normalizeYYYYMM(data); if(!data||!dataFmt) continue;
        out.push({ nome, data, dataFmt, cs: toNum(cs), nps: toNum(nps), neg: toNum(neg), sla1ok: Number(sla1ok||0), sla1off: Number(sla1off||0), sla2ok: Number(sla2ok||0), sla2off: Number(sla2off||0), gestor: gestor||"", celular: celular||"", agente: agente||"" });
      }
      return out;
    };

    // First attempt: header-based
    importados = byHeader();
    // Heuristics: if data seems suspicious, retry positional
    const validCs = importados.filter(r=>!isNaN(Number(r.cs))).length;
    const validNps = importados.filter(r=>!isNaN(Number(r.nps))).length;
    const validNeg = importados.filter(r=>!isNaN(Number(r.neg))).length;
    const tooFewMetrics = importados.length>0 && ((validCs/importados.length)<0.2 || (validNps/importados.length)<0.2 || (validNeg/importados.length)<0.2);
    if(importados.length===0 || tooFewMetrics){
      importados = byPosition();
    }
    // Additional heuristic: if few rows have SLA totals > 0, mapping likely failed for SLA headers
    const slaRows = importados.filter(r => (((Number(r.sla1ok)||0)+(Number(r.sla1off)||0)+(Number(r.sla2ok)||0)+(Number(r.sla2off)||0)) > 0)).length;
    const lowSlaCoverage = importados.length>0 && (slaRows/importados.length) < 0.2;
    // If NEG appears implausibly high across the dataset, mapping may have grabbed SLA columns as NEG
    let negMax = 0; try{ negMax = Math.max.apply(null, importados.map(r=>{ const v=Number(r.neg); return isNaN(v)?0:v; })); }catch(e){ negMax = 0; }
    const negLooksWrong = negMax > 20;
    if(lowSlaCoverage || negLooksWrong){
      const alt = byPosition();
      if(alt && alt.length) importados = alt;
    }

    // Atualiza as variÃ¡veis globais
    clientes = importados;
    preparaClientes(clientes);
    // Se muitos CHS ficaram idÃªnticos (ex.: tudo 38), tenta fallback posicional
    const uniqueChs = new Set((clientes||[]).map(c=>c.chs)).size;
    if(clientes.length>30 && uniqueChs<=3){
      const alt = byPosition();
      if(alt && alt.length){ clientes = alt; preparaClientes(clientes); }
    }
    clientesFiltrados = [...clientes];

    // Atualiza os filtros de MÃªs na tela
    const meses = Array.from(new Set(clientes.map(c=>c.dataFmt).filter(Boolean))).sort();
    const sel = document.getElementById('mesSelect');
    if(sel){
         // Preenche o select e seleciona "Todos" por padrÃ£o
         sel.innerHTML = `<option value="all">Todos</option>` + meses.map(m=>`<option value="${m}">${formatMesAno(m)}</option>`).join('');
         sel.value = 'all';
         currentMes = 'all';
    }

    // Renderiza o dashboard
    populateCompareMonthSelects();
    renderDashboard();
    try{ console.log(`Sucesso: ${clientes.length} clientes carregados.`); }catch(e){}
  }catch(erro){
    try{ console.error(erro); }catch(e){}
    alert('Erro ao processar os dados.');
  }
}

function populateCompareMonthSelects(){
  const meses = Array.from(new Set(clientes.map(c=>c.dataFmt).filter(Boolean))).sort();
  const sel1 = document.getElementById('compareModalMesSelect');
  const selTop = document.getElementById('compareModalMesSelectTop');
  const options = `<option value="all">Todos</option>` + meses.map(m=>`<option value="${m}">${formatMesAno(m)}</option>`).join('');
  if(sel1) sel1.innerHTML = options;
  if(selTop) selTop.innerHTML = options;

  // also sync floating month select if it exists
  const floatMes = document.getElementById('floatMesSelect');
  const mainMes = document.getElementById('mesSelect');
  if(floatMes && mainMes) floatMes.innerHTML = mainMes.innerHTML;
}

/* FIXED: getViewList now correctly applies the status filter to aggregated data when currentMes === 'all'
   so when "Todos" is selected, filtering by Saude/AtenÃ§Ã£o/CrÃ­tico uses the per-client average CHS across months.
*/
function getViewList(){
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];

  // respect explicit selectedClients (if user picked a subset)
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

  if(currentMes && currentMes !== 'all') {
    // month-specific view: aggregate per client for that month to keep consistency across rankings
    const rows = base.filter(c => c.dataFmt === currentMes);
    let aggregatedMonth = aggregateByName(rows);
    if(statusFilter && statusFilter !== 'all') {
      aggregatedMonth = aggregatedMonth.filter(c => {
        const st = getStatusCHS(c.chs).cls;
        return st === statusFilter;
      });
    }
    return aggregatedMonth;
  } else {
    // "Todos" -> para cada cliente, mostrar a nota do ÃšLTIMO mÃªs disponÃ­vel (consistente com o delta mostrado)
    const names = Array.from(new Set((base||[]).map(c=>c.nome)));
    let out = names.map(name => {
      const monthsForClient = Array.from(new Set((clientes||[])
        .filter(r => r.nome === name && r.dataFmt)
        .map(r => normalizeYYYYMM(r.dataFmt)))).sort();
      const len = monthsForClient.length;
      const lastMonth = len ? monthsForClient[len - 1] : null;
      const chsLast = lastMonth ? getCHSForClientInMonth(name, lastMonth) : null;
      if(lastMonth==null || chsLast==null) return null; // exclude clients without last-month data
      return { nome: name, chs: chsLast };
    }).filter(it => it && typeof it.chs === 'number');
    if(statusFilter && statusFilter !== 'all') {
      out = out.filter(c => getStatusCHS(c.chs).cls === statusFilter);
    }
    return out;
  }
}

/* New helper: count visible unique client names considering current search/filter/selection/month */
function getVisibleUniqueClientCount(){
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];

  // apply selectedClients filter if user has explicitly selected a subset
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

  // when filtering by month, work on records; otherwise aggregation per client
  if(currentMes && currentMes !== 'all'){
    base = base.filter(c => c.dataFmt === currentMes);
    if(statusFilter && statusFilter !== 'all'){
      base = base.filter(c => getStatusCHS(c.chs).cls === statusFilter);
    }
    const names = new Set((base||[]).map(r => r.nome));
    return names.size;
  } else {
    // aggregate per name for "Todos"
    let aggregated = aggregateByName(base);
    if(statusFilter && statusFilter !== 'all'){
      aggregated = aggregated.filter(a => getStatusCHS(a.chs).cls === statusFilter);
    }
    return aggregated.length;
  }
}

function onMesChange(val){
  currentMes = val || 'all';
  // sync float select if present
  const floatMes = document.getElementById('floatMesSelect');
  const mainMes = document.getElementById('mesSelect');
  if(floatMes && mainMes && floatMes.value !== mainMes.value) floatMes.value = mainMes.value;
  rankingPage = 1;
  renderDashboard();
  renderSelectModalList();
  renderCompareSelector();
}

function filtrarClientes() {
  const mainEl = document.getElementById('searchInput');
  const floatEl = document.getElementById('floatSearchInput');
  const val = (mainEl && typeof mainEl.value === 'string') ? mainEl.value : (floatEl && typeof floatEl.value === 'string' ? floatEl.value : '');
  const searchTerm = (val || '').toLowerCase();
  if (!searchTerm) clientesFiltrados = [...(clientes || [])];
  else clientesFiltrados = (clientes || []).filter(cliente => ((cliente.nome || '').toLowerCase().includes(searchTerm)));
  rankingPage = 1;
  renderDashboard();
  // Keep suggestions updated as user types
  try{ renderSuggestions(); }catch(e){}
}

/* per-chart type toggling */
function toggleChartTypeFor(which){
  const types = ['bar','line'];
  const typesDistrib = ['bar','doughnut'];
  if(which === 'distrib'){
    const idx = typesDistrib.indexOf(chartTypeDistrib);
    chartTypeDistrib = typesDistrib[(idx+1) % typesDistrib.length];
    createChartDistribuicao();
  } else if(which === 'evol'){
    const idx = types.indexOf(chartTypeEvol);
    chartTypeEvol = types[(idx+1) % types.length];
    createChartEvolucao();
  } else if(which === 'sla'){
    const idx = types.indexOf(chartTypeSLA);
    chartTypeSLA = types[(idx+1) % types.length];
    createChartSLA();
  } else if(which === 'cs'){
    const idx = types.indexOf(chartTypeCS);
    chartTypeCS = types[(idx+1) % types.length];
    createChartCS();
  } else if(which === 'nps'){
    const idx = types.indexOf(chartTypeNPS);
    chartTypeNPS = types[(idx+1) % types.length];
    createChartNPS();
  } else if(which === 'neg'){
    const idx = types.indexOf(chartTypeNEG);
    chartTypeNEG = types[(idx+1) % types.length];
    createChartNEG();
  }
}

/* handle clicks on summary boxes to filter by status or show all */
function onSummaryClick(key){
  statusFilter = key === 'all' ? 'all' : key;
  rankingPage = 1;
  renderDashboard();
}

/* Rendering dashboard and parts */
function renderDashboard(){
  renderSummary();
  renderTable();
  createCharts();
  renderRankings();
  renderSelectModalList();
  renderCompareSelector();
}

/* Utility: get list of all months present (sorted ascending) */
function getAllMonthsSorted(){
  const meses = Array.from(new Set((clientes || []).map(c=>c.dataFmt).filter(Boolean))).sort();
  return meses;
}

/* Utility: returns previous month in 'YYYY-MM' format or null */
function previousMonthString(ym){
  if(!ym) return null;
  const parts = ym.split('-');
  if(parts.length < 2) return null;
  let y = parseInt(parts[0],10), m = parseInt(parts[1],10);
  if(isNaN(y) || isNaN(m)) return null;
  m = m - 1;
  if(m < 1){ y = y - 1; m = 12; }
  if(y < 0) return null;
  const mm = m < 10 ? '0' + m : '' + m;
  return `${y}-${mm}`;
}

/* Utility: get CHS for a client in a given month WITHOUT fallback.
   If there are no records for that client in that month, return null.
   This avoids inferring tendÃªncia (alta/queda) quando nÃ£o hÃ¡ mÃªs anterior vÃ¡lido. */
function getCHSForClientInMonth(name, month){
  if(!month) return null;
  const target = normalizeYYYYMM(month);
  if(!target) return null;
  const rows = (clientes || []).filter(c => c.nome === name && normalizeYYYYMM(c.dataFmt) === target);
  if(rows.length === 0) return null;
  const avg = Math.round(rows.reduce((s,r)=> s + (Number(r.chs)||0), 0) / rows.length);
  return Math.max(0, Math.min(100, avg));
}

/* Rendering functions for rankings, charts, table, client modal etc. */
function renderRankings(){
  // Determine how many unique clients are visible under current filters/search/month
  const visibleUniqueCount = getVisibleUniqueClientCount();

  const pioresContainer = document.getElementById('rankingPiores');
  const melhoresContainer = document.getElementById('rankingMelhores');

  // When fewer than 6 unique clients are visible, hide the side rankings (same logic as 'Selecionar clientes' behavior),
  // and only show the geral ranking. This also applies when searching a single client.
  if (visibleUniqueCount >= 6) {
    if (pioresContainer) pioresContainer.style.display = '';
    if (melhoresContainer) melhoresContainer.style.display = '';
    renderRankingPiores();
    renderRankingMelhores();
    try{ const row = document.querySelector('.dashboard-rankings-row'); if(row) row.classList.remove('one-only'); }catch(e){}
  } else {
    if (pioresContainer) pioresContainer.style.display = 'none';
    if (melhoresContainer) melhoresContainer.style.display = 'none';
    const pList = document.getElementById('rankingPioresList');
    const mList = document.getElementById('rankingMelhoresList');
    if (pList) pList.innerHTML = '';
    if (mList) mList.innerHTML = '';
    try{ const row = document.querySelector('.dashboard-rankings-row'); if(row) row.classList.add('one-only'); }catch(e){}
  }

  renderRankingGeral();
}

function renderSummary(){
  const view = getViewList();
  const total = view.length || 0;
  // thresholds updated per your request:
  // SaudÃ¡vel: >=70, AtenÃ§Ã£o: >=40 && <70, CrÃ­tico: <40
  const saudavel = view.filter(c=>c.chs>=70).length;
  const atencao = view.filter(c=>c.chs>=40 && c.chs < 70).length;
  const critico = view.filter(c=>c.chs<40).length;
  const chsGeral = total ? Math.round(view.reduce((sum,c)=>sum+c.chs,0)/total) : '--';
  document.getElementById('chsTotalVal').textContent = total;
  document.getElementById('chsSaudavelVal').textContent = saudavel;
  document.getElementById('chsAtencaoVal').textContent = atencao;
  document.getElementById('chsCriticoVal').textContent = critico;
  document.getElementById('chsGeralValor').textContent=chsGeral;

  ['chsTotal','chsSaudavel','chsAtencao','chsCritico'].forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    el.style.boxShadow = '';
    el.style.transform = '';
  });
  if(statusFilter === 'all') {
    const el = document.getElementById('chsTotal'); if(el){ el.style.boxShadow='0 6px 20px rgba(0,0,0,0.08)'; el.style.transform='translateY(-4px)'; }
  } else if(statusFilter === 'saude') {
    const el = document.getElementById('chsSaudavel'); if(el){ el.style.boxShadow='0 6px 20px rgba(0,0,0,0.08)'; el.style.transform='translateY(-4px)'; }
  } else if(statusFilter === 'atencao') {
    const el = document.getElementById('chsAtencao'); if(el){ el.style.boxShadow='0 6px 20px rgba(0,0,0,0.08)'; el.style.transform='translateY(-4px)'; }
  } else if(statusFilter === 'critico') {
    const el = document.getElementById('chsCritico'); if(el){ el.style.boxShadow='0 6px 20px rgba(0,0,0,0.08)'; el.style.transform='translateY(-4px)'; }
  }

  // Update CHS Geral box to reflect the cognitive state and heart/icon color
  try{
    const geralEl = document.getElementById('chsGeralBox');
    const heartEl = document.getElementById('chsHeart');
    if(geralEl){
      // remove previous status classes
      geralEl.classList.remove('saude','atencao','critico');
      if(chsGeral !== '--' && !isNaN(Number(chsGeral))){
        const statusObj = getStatusCHS(Number(chsGeral));
        // Add status class so CSS rules color the heart and background appropriately
        geralEl.classList.add(statusObj.cls);
        if(heartEl) {
          // Change the displayed icon according to status:
          if(statusObj.cls === 'saude') {
            heartEl.textContent = 'ðŸ’š';
          } else if(statusObj.cls === 'atencao') {
            // attention icon (will be colored by CSS via parent .atencao)
            heartEl.textContent = 'âš ï¸';
          } else {
            // critical -> red X icon
            heartEl.textContent = 'âŒ';
          }
        }
      } else {
        if(heartEl) heartEl.textContent = 'ðŸ’š';
      }
    }
  } catch(e){}
}

function renderTable(){
  let tbody=document.querySelector('#chs-table tbody');
  if(!tbody) return;
  tbody.innerHTML='';
  const base = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let rows = (currentMes && currentMes !== 'all') ? base.filter(c=>c.dataFmt===currentMes) : base;
  if(selectedClients && selectedClients.size > 0) rows = rows.filter(r => selectedClients.has(r.nome));
  if(statusFilter && statusFilter !== 'all') rows = rows.filter(r => getStatusCHS(r.chs).cls === statusFilter);
  (rows||[]).forEach(cli=>{
    let status=getStatusCHS(cli.chs);
    let row=document.createElement('tr');
    row.innerHTML=`
      <td><span class="client-card" title="${escapeHtml(cli.nome)}" onclick="abrirClienteModal('${escapeHtml(cli.nome)}')">${escapeHtml(cli.nome)}</span></td>
      <td>${escapeHtml(cli.data)}</td>
      <td><b>${cli.chs}</b></td>
      <td><span class="status ${status.cls}">${status.txt}</span></td>
      <td>${cli.cs||'-'}</td>
      <td>${cli.nps||'-'}</td>
      <td>${cli.neg||'-'}</td>
      <td>${cli.sla1ok||'-'}</td>
      <td>${cli.sla1off||'-'}</td>
      <td>${cli.sla2ok||'-'}</td>
      <td>${cli.sla2off||'-'}</td>
      <td>
        <button class="btn" onclick="verDetalhes('${escapeHtml(cli.nome)}')">Ver</button>
        <button class="btn" onclick="editarCliente('${escapeHtml(cli.nome)}')">Editar</button>
        <button class="btn" onclick="ligarCliente('${escapeHtml(cli.nome)}')">Ligar</button>
      </td>
    `;
    tbody.appendChild(row);
  });
}

function createCharts(){
  try{ recalculateAllChs(); }catch(e){}
  createChartDistribuicao();
  // Ensure TrendUp chart is created initially as it is visible by default
  try{ createChartTrendUp(); }catch(e){}
  createChartIndicadores();
}

/* Charts months menu removed */

  function createChartDistribuicao(){
  const canvas = document.getElementById('chartChsDistrib');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartChsDistrib) chartChsDistrib.destroy();
  const view = getViewList();
  // thresholds parametrizados
  const thSaude = (CHS_CONFIG && CHS_CONFIG.thresholds && CHS_CONFIG.thresholds.saude) || 70;
  const thAtencao = (CHS_CONFIG && CHS_CONFIG.thresholds && CHS_CONFIG.thresholds.atencao) || 40;
  const saudavel = view.filter(c=>c.chs>=thSaude).length;
  const atencao = view.filter(c=>c.chs>=thAtencao && c.chs < thSaude).length;
  const critico = view.filter(c=>c.chs<thAtencao).length;
  const typeRaw = chartTypeDistrib || 'bar';
  const type = (typeRaw === 'bar' || typeRaw === 'doughnut') ? typeRaw : 'doughnut';
  const labels = ['SaudÃ¡vel','AtenÃ§Ã£o','CrÃ­tico'];
  const dataArr = [saudavel, atencao, critico];
  const colors = ['#009f42','#ffc900','#e53935'];

  const barDataset = { data:dataArr, backgroundColor:colors, borderColor:['#007a33','#e6b400','#c62828'], borderWidth:2, barPercentage:0.95, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
  const donutDataset = { data:dataArr, backgroundColor:colors, borderColor:'#ffffff', borderWidth:2 };
  const lineDataset = { label:'DistribuiÃ§Ã£o CHS', data:dataArr, fill:true, backgroundColor:'rgba(0,207,255,0.18)', borderColor:'#0b63b7', pointBackgroundColor:'#0b63b7', pointBorderColor:'#fff', pointBorderWidth:2, pointRadius:4, pointHoverRadius:6, borderWidth:3 };
  const dataset = (type==='bar') ? barDataset : (type==='doughnut' ? donutDataset : lineDataset);

  let options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display: type==='pie' || type==='doughnut', position: (type==='doughnut' ? 'top' : 'top'), labels:{ boxWidth:12 } } } };
  if(type==='bar'){
    options.scales = { y:{ beginAtZero:true } };
    options.animation = false;
  } else if(type==='doughnut'){
    options.cutout = '60%';
    options.plugins.tooltip = { callbacks: { label: (ctx)=> `${ctx.label}: ${ctx.parsed}` } };
    // grid background handled by DoughnutGridBG plugin
  }

  chartChsDistrib = new Chart(ctx, { type, data:{ labels, datasets:[dataset] }, options });
  try { animateChartRender('chartChsDistrib'); } catch(e){}
}

function createChartEvolucao(){
  let ctx=document.getElementById('chartChsEvolucao').getContext('2d');
  if(chartChsEvolucao) chartChsEvolucao.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  let mesesMap={};
  (base||[]).forEach(cli=>{ if(cli.dataFmt){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(cli.chs); }});
  let meses=Object.keys(mesesMap).sort();
  let medias=meses.map(m=>Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
  let chartType = chartTypeEvol || 'bar';
  let effectiveType = (chartType === 'pie' || chartType === 'doughnut') ? 'line' : chartType;

  // Compute diffs between consecutive months to style up/down trends
  const diffs = medias.map((v,i) => i===0 ? 0 : v - medias[i-1]);
  const upColor = '#009f42';     // tryvia green
  const downColor = '#e53935';   // tryvia red
  const neutralColor = '#0b63b7';// tryvia blue
  const cyanFill = 'rgba(0,207,255,0.18)';

  // Per-point background color (based on delta vs mÃªs anterior)
  const pointBg = diffs.map(d => d>0 ? upColor : (d<0 ? downColor : neutralColor));
  const barBg = pointBg; // same logic for bars

  const labelsFmt = meses.map(formatMesAno);
  const datasetCommon = {
    label: 'CHS MÃ©dio',
    data: medias,
    borderWidth: 2
  };

  let dataset;
  let options;
  if(effectiveType === 'line'){
    dataset = Object.assign({}, datasetCommon, {
      fill: true,
      backgroundColor: cyanFill,
      borderColor: neutralColor, // default, segments will override
      pointBackgroundColor: pointBg,
      pointBorderColor: '#ffffff',
      pointBorderWidth: 2,
      pointRadius: 4,
      pointHoverRadius: 6,
      segment: {
        borderColor: ctx => {
          const dy = ctx.p1.parsed.y - ctx.p0.parsed.y;
          return dy>0 ? upColor : (dy<0 ? downColor : neutralColor);
        },
        borderWidth: 3
      }
    });
    options = {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ display:true },
        tooltip:{
          callbacks:{
            label: (context)=>{
              const i = context.dataIndex;
              const val = context.parsed.y;
              if(i===0) return `CHS: ${val}`;
              const prevCal = previousMonthString(meses[i]);
              if(meses[i-1] !== prevCal) return `CHS: ${val}`;
              const d = val - medias[i-1];
              const arrow = d>0 ? 'â–²' : (d<0 ? 'â–¼' : 'â€”');
              const signVal = d>0 ? `+${d}` : `${d}`;
              return `CHS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`;
            }
          }
        },
        targetLine: { y: 70, color: '#666', width: 2, dash: [6,4] }
      },
      scales: { y: { beginAtZero:true, max: 100 } }
    };
  } else {
    // Bar style per month colored by movement vs mÃªs anterior
    dataset = Object.assign({}, datasetCommon, {
      backgroundColor: barBg,
      borderColor: barBg,
      borderWidth: 2,
      barPercentage: 0.95,
      categoryPercentage: 0.9,
      maxBarThickness: 44,
      borderRadius: 12,
      borderSkipped: 'bottom',
      animations: { y: { from: 0 } }
    });
    options = {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ display:true },
        tooltip:{
          callbacks:{
            label: (context)=>{
              const i = context.dataIndex;
              const val = context.parsed.y;
              if(i===0) return `CHS: ${val}`;
              const prevCal = previousMonthString(meses[i]);
              if(meses[i-1] !== prevCal) return `CHS: ${val}`;
              const d = val - medias[i-1];
              const arrow = d>0 ? 'â–²' : (d<0 ? 'â–¼' : 'â€”');
              const signVal = d>0 ? `+${d}` : `${d}`;
              return `CHS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`;
            }
          }
        },
        targetLine: { y: 70, color: '#666', width: 2, dash: [6,4] }
      },
      scales: { y: { beginAtZero:true, max: 100 } }
    };
    options.animation = false;
  }

  chartChsEvolucao = new Chart(ctx, {
    type: effectiveType,
    data: { labels: labelsFmt, datasets: [dataset] },
    options
  });
  try { animateChartRender('chartChsEvolucao'); } catch(e){}
}

function createChartChsBreakdown(){
  const canvas = document.getElementById('chartChsBreakdown'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartChsBreakdown) chartChsBreakdown.destroy();
  const view = (typeof getViewList === 'function') ? getViewList() : (clientesFiltrados && clientesFiltrados.length ? clientesFiltrados : clientes);
  const w = normalizeWeights(CHS_CONFIG.weights);
  // mÃ©dia das mÃ©tricas normalizadas para a visÃ£o atual
  const acc = { cs:0, nps:0, neg:0, sla:0, n:0, has:{cs:0,nps:0,neg:0,sla:0} };
  (view||[]).forEach(cli=>{
    const m = normalizeMetrics(cli);
    if(m.cs!=null){ acc.cs += m.cs; acc.has.cs++; }
    if(m.nps!=null){ acc.nps += m.nps; acc.has.nps++; }
    if(m.neg!=null){ acc.neg += m.neg; acc.has.neg++; }
    if(m.sla!=null){ acc.sla += m.sla; acc.has.sla++; }
    acc.n++;
  });
  const avg = {
    cs: acc.has.cs? Math.round(acc.cs/acc.has.cs):0,
    nps: acc.has.nps? Math.round(acc.nps/acc.has.nps):0,
    neg: acc.has.neg? Math.round(acc.neg/acc.has.neg):0,
    sla: acc.has.sla? Math.round(acc.sla/acc.has.sla):0
  };
  const labels = ['CS','NPS','SLA','Negativas(â—€ melhor)'];
  const values = [avg.cs*w.cs, avg.nps*w.nps, avg.sla*w.sla, avg.neg*w.neg].map(v=> Math.round(v));
  const colors = ['#6b43b8','#0b63b7','#009f42','#e53935'];
  const type = chartTypeBreakdown === 'doughnut' ? 'doughnut' : 'bar';
  const datasetBar = { data: values, backgroundColor: colors, borderColor: colors, borderWidth:2, barPercentage:0.9, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
  const datasetDonut = { data: values, backgroundColor: colors, borderColor:'#fff', borderWidth:2 };
  const dataset = (type==='bar') ? datasetBar : datasetDonut;
  let options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label:(ctx)=> `${labels[ctx.dataIndex]}: ${ctx.parsed}` } } } };
  if(type==='bar') options.scales = { y:{ beginAtZero:true, max:100 } };
  chartChsBreakdown = new Chart(ctx, { type, data:{ labels, datasets:[dataset] }, options });
  try { animateChartRender('chartChsBreakdown'); } catch(e){}
}

/* Trend charts on main dashboard */
function createChartTrendDown(){
  const canvas = document.getElementById('chartTrendDown'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartTrendDown) chartTrendDown.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const months = Array.from(new Set((base||[]).map(c=>c.dataFmt).filter(Boolean))).sort();
  const names = Array.from(new Set((base||[]).map(c=>(c.nome||'').toString().trim()).filter(Boolean)));
  const labelsFmt = months.map(formatMesAno);
  const dataSeries = months.map(m=>{
    const curr = normalizeYYYYMM(m); const prev = previousMonthString(curr);
    if(!prev) return 0;
    let down=0, total=0;
    for(const n of names){
      const pv = getCHSForClientInMonth(n, prev); const cv = getCHSForClientInMonth(n, curr);
      if(pv==null || cv==null) continue; total++; if(cv < pv) down++;
    }
    return total ? Math.round((down/total)*1000)/10 : 0;
  });
  chartTrendDown = new Chart(ctx, {
    type:'line',
    data:{ labels: labelsFmt, datasets:[{ label:'% em queda', data:dataSeries, fill:true, backgroundColor:'rgba(229,57,53,0.12)', borderColor:'#e53935', borderWidth:3, pointRadius:4, pointHoverRadius:6, tension:0.25 }] },
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(ctx)=> (ctx.parsed.y??0) + '%' } } }, scales:{ y:{ beginAtZero:true, max:100, ticks:{ stepSize:20, callback:v=> v+'%' } } } }
  });
  try { animateChartRender('chartTrendDown'); } catch(e){}
}
function createChartTrendUp(){
  const canvas = document.getElementById('chartTrendUp'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartTrendUp) chartTrendUp.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const months = Array.from(new Set((base||[]).map(c=>c.dataFmt).filter(Boolean))).sort();
  const names = Array.from(new Set((base||[]).map(c=>(c.nome||'').toString().trim()).filter(Boolean)));
  const labelsFmt = months.map(formatMesAno);
  const upPercs = [], downPercs = [], neutralPercs = [];
  months.forEach(m=>{
    const curr = normalizeYYYYMM(m); const prev = previousMonthString(curr);
    if(!prev){ upPercs.push(0); downPercs.push(0); neutralPercs.push(0); return; }
    let up=0, down=0, neutral=0, total=0;
    for(const n of names){
      const pv = getCHSForClientInMonth(n, prev); const cv = getCHSForClientInMonth(n, curr);
      if(pv==null || cv==null) continue; total++;
      if(cv > pv) up++; else if(cv < pv) down++; else neutral++;
    }
    const denom = total || 1;
    upPercs.push(Math.round((up/denom)*1000)/10);
    downPercs.push(Math.round((down/denom)*1000)/10);
    neutralPercs.push(Math.round((neutral/denom)*1000)/10);
  });
  chartTrendUp = new Chart(ctx, {
    type:'line',
    data:{ labels: labelsFmt, datasets:[
      { label:'% em alta', data: upPercs, fill:false, borderColor:'#009f42', backgroundColor:'rgba(0,159,66,0.12)', borderWidth:3, pointRadius:4, pointHoverRadius:6, tension:0.25 },
      { label:'% em queda', data: downPercs, fill:false, borderColor:'#e53935', backgroundColor:'rgba(229,57,53,0.12)', borderWidth:3, pointRadius:4, pointHoverRadius:6, tension:0.25 },
      { label:'% neutros', data: neutralPercs, fill:false, borderColor:'#0b63b7', backgroundColor:'rgba(11,99,183,0.12)', borderWidth:3, pointRadius:4, pointHoverRadius:6, tension:0.25 }
    ] },
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(ctx)=> `${ctx.dataset.label}: ${(ctx.parsed.y??0)}%` } } }, scales:{ y:{ beginAtZero:true, max:100, ticks:{ stepSize:20, callback:v=> v+'%' } } } }
  });
  try { animateChartRender('chartTrendUp'); } catch(e){}
}

/* ========= New indicator charts ========= */
function createChartSLA(){
  const canvas = document.getElementById('chartSlaEvolucao'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartSlaEvolucao) chartSlaEvolucao.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const mesesMap = {};
  (base||[]).forEach(cli => {
    if(!cli.dataFmt) return;
    // compute SLA% per row
    const t1 = Number(cli.sla1ok)||0, f1 = Number(cli.sla1off)||0, t2 = Number(cli.sla2ok)||0, f2 = Number(cli.sla2off)||0;
    const p1 = (t1+f1) > 0 ? (t1/(t1+f1)) : null;
    const p2 = (t2+f2) > 0 ? (t2/(t2+f2)) : null;
    const pct = (p1!=null && p2!=null) ? Math.round(((p1+p2)/2)*100) : (p1!=null ? Math.round(p1*100) : (p2!=null ? Math.round(p2*100) : null));
    if(pct==null) return;
    if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
    mesesMap[cli.dataFmt].push(pct);
  });
  let meses = Object.keys(mesesMap).sort();
  // SLA must be shown in %: average of row percentages per month
  let series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
  const diffs = series.map((v,i)=> i===0 ? 0 : v - series[i-1]);
  const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
  const pointBg = diffs.map(d => d>0 ? upColor : (d<0 ? downColor : neutralColor));
  const labelsFmt = meses.map(formatMesAno);
  const effectiveType = chartTypeSLA || 'line';
  let dataset, options;
  if(effectiveType === 'line'){
    dataset = { label:'SLA (%)', data:series, fill:true, backgroundColor:cyanFill, borderColor:neutralColor, pointBackgroundColor:pointBg, pointBorderColor:'#fff', pointBorderWidth:2, pointRadius:4, pointHoverRadius:6, borderWidth:3, segment:{ borderColor: ctx=>{ const dy=ctx.p1.parsed.y-ctx.p0.parsed.y; return dy>0?upColor:(dy<0?downColor:neutralColor); } } };
    options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `SLA: ${val}%`; const prevCal=previousMonthString(meses[i]); if(meses[i-1]!==prevCal) return `SLA: ${val}%`; const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `SLA: ${val}%  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:100 } } };
  } else {
    dataset = { label:'SLA (%)', data:series, backgroundColor:pointBg, borderColor:pointBg, borderWidth:2, barPercentage:0.95, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
    options = { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `SLA: ${val}%`; const prevCal = previousMonthString(meses[i]); if(meses[i-1] !== prevCal) return `SLA: ${val}%`; const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `SLA: ${val}%  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:100 } } };
  }
  chartSlaEvolucao = new Chart(ctx, { type: effectiveType, data:{ labels: labelsFmt, datasets:[dataset] }, options });
  try { animateChartRender('chartSlaEvolucao'); } catch(e){}
}

function createChartCS(){
  const canvas = document.getElementById('chartCsEvolucao'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartCsEvolucao) chartCsEvolucao.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const mesesMap = {};
  (base||[]).forEach(cli=>{ if(cli.dataFmt && !isNaN(Number(cli.cs))){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(Number(cli.cs)); } });
  let meses = Object.keys(mesesMap).sort();
  let series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
  const diffs = series.map((v,i)=> i===0 ? 0 : v - series[i-1]);
  const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
  const pointBg = diffs.map(d => d>0 ? upColor : (d<0 ? downColor : neutralColor));
  const labelsFmt = meses.map(formatMesAno);
  const effectiveType = chartTypeCS || 'line';
  let dataset, options;
  if(effectiveType === 'line'){
    dataset = { label:'CS MÃ©dio', data:series, fill:true, backgroundColor:cyanFill, borderColor:neutralColor, pointBackgroundColor:pointBg, pointBorderColor:'#fff', pointBorderWidth:2, pointRadius:4, pointHoverRadius:6, borderWidth:3, segment:{ borderColor: ctx=>{ const dy=ctx.p1.parsed.y-ctx.p0.parsed.y; return dy>0?upColor:(dy<0?downColor:neutralColor); } } };
    options = {
      responsive:true,
      maintainAspectRatio:false,
      plugins:{
        legend:{ display:true },
        tooltip:{ callbacks:{ label: (context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `CS: ${val}`; const prevCal = previousMonthString(meses[i]); if(meses[i-1] !== prevCal) return `CS: ${val}`; const d=val - series[i-1]; const arrow = d>0 ? 'â–²' : (d<0 ? 'â–¼' : 'â€”'); const signVal = d>0 ? `+${d}` : `${d}`; return `CS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } }
      },
      scales:{ y:{ beginAtZero:true, max:10 } }
    };
  } else {
    dataset = { label:'CS MÃ©dio', data:series, backgroundColor:pointBg, borderColor:pointBg, borderWidth:2, barPercentage:0.95, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
    options = { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `CS: ${val}`; const prevCal = previousMonthString(meses[i]); if(meses[i-1] !== prevCal) return `CS: ${val}`; const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `CS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:10 } } };
  }
  chartCsEvolucao = new Chart(ctx, { type: effectiveType, data:{ labels: labelsFmt, datasets:[dataset] }, options });
  try { animateChartRender('chartCsEvolucao'); } catch(e){}
}

function createChartNPS(){
  const canvas = document.getElementById('chartNpsEvolucao'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartNpsEvolucao) chartNpsEvolucao.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const mesesMap = {};
  (base||[]).forEach(cli=>{ if(cli.dataFmt && !isNaN(Number(cli.nps))){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(Number(cli.nps)); } });
  let meses = Object.keys(mesesMap).sort();
  let series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
  const diffs = series.map((v,i)=> i===0 ? 0 : v - series[i-1]);
  const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
  const pointBg = diffs.map(d => d>0 ? upColor : (d<0 ? downColor : neutralColor));
  const labelsFmt = meses.map(formatMesAno);
  const effectiveType = chartTypeNPS || 'line';
  let dataset, options;
  if(effectiveType === 'line'){
    dataset = { label:'NPS MÃ©dio', data:series, fill:true, backgroundColor:cyanFill, borderColor:neutralColor, pointBackgroundColor:pointBg, pointBorderColor:'#fff', pointBorderWidth:2, pointRadius:4, pointHoverRadius:6, borderWidth:3, segment:{ borderColor: ctx=>{ const dy=ctx.p1.parsed.y-ctx.p0.parsed.y; return dy>0?upColor:(dy<0?downColor:neutralColor); } } };
    options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `NPS: ${val}`; const prevCal=previousMonthString(meses[i]); if(meses[i-1]!==prevCal) return `NPS: ${val}`; const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `NPS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:10 } } };
  } else {
    dataset = { label:'NPS MÃ©dio', data:series, backgroundColor:pointBg, borderColor:pointBg, borderWidth:2, barPercentage:0.95, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
    options = { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `NPS: ${val}`; const prevCal = previousMonthString(meses[i]); if(meses[i-1] !== prevCal) return `NPS: ${val}`; const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `NPS: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:10 } } };
  }
  chartNpsEvolucao = new Chart(ctx, { type: effectiveType, data:{ labels: labelsFmt, datasets:[dataset] }, options });
  try { animateChartRender('chartNpsEvolucao'); } catch(e){}
}

function createChartNEG(){
  const canvas = document.getElementById('chartNegEvolucao'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartNegEvolucao) chartNegEvolucao.destroy();
  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));
  const mesesMap = {};
  (base||[]).forEach(cli=>{
    if(!cli.dataFmt) return;
    let raw = (cli.neg !== undefined ? cli.neg : null);
    if(raw === null || raw === '' || isNaN(Number(raw))){
      raw = (cli.negativas !== undefined ? cli.negativas : raw);
    }
    if(raw === null || raw === '' || isNaN(Number(raw))){
      raw = (cli.avNeg !== undefined ? cli.avNeg : raw);
    }
    if(raw === null || raw === '' || isNaN(Number(raw))){
      raw = (cli.av_neg !== undefined ? cli.av_neg : raw);
    }
    if(raw === null || raw === '' || isNaN(Number(raw))){
      raw = (cli.avNegFresh !== undefined ? cli.avNegFresh : raw);
    }
    let val = null;
    if(raw !== null && raw !== undefined){
      const s = String(raw).replace(',', '.').replace(/[^0-9.\-]/g,'');
      const n = parseFloat(s);
      if(!isNaN(n)) val = n;
    }
    if(val === null) return;
    if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
    mesesMap[cli.dataFmt].push(val);
  });
  const meses = Object.keys(mesesMap).sort();
  const series = meses.map(m => mesesMap[m].reduce((a,b)=>a+b,0));
  const diffs = series.map((v,i)=> i===0 ? 0 : v - series[i-1]);
  const upColor = '#e53935', downColor = '#009f42', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
  // For negatives, up is worse, so invert colors: increase -> red, decrease -> green
  const pointBg = diffs.map(d => d>0 ? upColor : (d<0 ? downColor : neutralColor));
  const labelsFmt = meses.map(formatMesAno);
  const effectiveType = chartTypeNEG || 'line';
  const maxVal = series.reduce((m,v)=> Math.max(m, v||0), 0);
  const yMax = Math.max(5, Math.ceil(maxVal * 1.4));
  let dataset, options;
  if(effectiveType === 'line'){
    dataset = { label:'AvaliaÃ§Ãµes Negativas (Qtd)', data:series, fill:true, backgroundColor:cyanFill, borderColor:neutralColor, pointBackgroundColor:pointBg, pointBorderColor:'#fff', pointBorderWidth:2, pointRadius:4, pointHoverRadius:6, borderWidth:3, segment:{ borderColor: ctx=>{ const dy=ctx.p1.parsed.y-ctx.p0.parsed.y; return dy>0?'#e53935':(dy<0?'#009f42':neutralColor); } } };
    options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label: (context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `Negativas: ${val}`; const prevCal=previousMonthString(meses[i]); if(meses[i-1]!==prevCal) return `Negativas: ${val}`; const d=val - series[i-1]; const arrow = d>0 ? 'â–²' : (d<0 ? 'â–¼' : 'â€”'); const signVal = d>0 ? `+${d}` : `${d}`; return `Negativas: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:yMax } } };
  } else {
    dataset = { label:'AvaliaÃ§Ãµes Negativas (Qtd)', data:series, backgroundColor:pointBg, borderColor:pointBg, borderWidth:2, barPercentage:0.95, categoryPercentage:0.9, maxBarThickness:44, borderRadius:12, borderSkipped:'bottom' };
    options = { responsive:true, maintainAspectRatio:false, animation:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label: (context)=>{ const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `Negativas: ${val}`; const prevCal = previousMonthString(meses[i]); if(meses[i-1] !== prevCal) return `Negativas: ${val}`; const d=val - series[i-1]; const arrow = d>0 ? 'â–²' : (d<0 ? 'â–¼' : 'â€”'); const signVal = d>0 ? `+${d}` : `${d}`; return `Negativas: ${val}  (${arrow} ${signVal} vs mÃªs anterior)`; } } } }, scales:{ y:{ beginAtZero:true, max:yMax } } };
  }
  chartNegEvolucao = new Chart(ctx, { type: effectiveType, data:{ labels: labelsFmt, datasets:[dataset] }, options });
  try { animateChartRender('chartNegEvolucao'); } catch(e){}
}

/* Unified indicators chart (NPS, SLA, Av Negativa, PercepÃ§Ã£o CS) */
function createChartIndicadores(){
  const canvas = document.getElementById('chartIndicadores');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  if(chartIndicadores) chartIndicadores.destroy();

  const baseAll = (clientesFiltrados && clientesFiltrados.length) ? clientesFiltrados : clientes;
  let base = baseAll || [];
  if(selectedClients && selectedClients.size > 0) base = base.filter(c => selectedClients.has(c.nome));

  const upColor = '#009f42', downColor = '#e53935', neutralColor = '#0b63b7', cyanFill = 'rgba(0,207,255,0.18)';
  const isTv = document.body && document.body.classList && document.body.classList.contains('tv-mode');
  const titleEl = document.getElementById('indicadorTitle');
  if(isTv && titleEl) titleEl.textContent = 'SLA / CS / NPS';

  let meses = [];
  let series = [];
  let labelsFmt = [];
  let labelText = '';
  let yMax = null;
  let yScaleMax = null;
  let tooltipPrefix = '';
  let tooltipSuffix = '';
  let invertColors = false; // for negatives

  if(isTv){
    // TV mode: overlay SLA, CS, NPS together on 0-100 scale
    const months = Array.from(new Set((base||[]).map(c=>c.dataFmt).filter(Boolean))).sort();
    const labels = months.map(formatMesAno);
    // Build maps for averages
    const mapNps = {}, mapCs = {}, mapSla = {};
    (base||[]).forEach(cli=>{
      if(!cli.dataFmt) return;
      // NPS
      if(!isNaN(Number(cli.nps))){ if(!mapNps[cli.dataFmt]) mapNps[cli.dataFmt]=[]; mapNps[cli.dataFmt].push(Number(cli.nps)); }
      // CS
      if(!isNaN(Number(cli.cs))){ if(!mapCs[cli.dataFmt]) mapCs[cli.dataFmt]=[]; mapCs[cli.dataFmt].push(Number(cli.cs)); }
      // SLA
      const t1 = Number(cli.sla1ok)||0, f1 = Number(cli.sla1off)||0, t2 = Number(cli.sla2ok)||0, f2 = Number(cli.sla2off)||0;
      const p1 = (t1+f1) > 0 ? (t1/(t1+f1)) : null;
      const p2 = (t2+f2) > 0 ? (t2/(t2+f2)) : null;
      const pct = (p1!=null && p2!=null) ? Math.round(((p1+p2)/2)*100) : (p1!=null ? Math.round(p1*100) : (p2!=null ? Math.round(p2*100) : null));
      if(pct!=null){ if(!mapSla[cli.dataFmt]) mapSla[cli.dataFmt]=[]; mapSla[cli.dataFmt].push(pct); }
    });
    const seriesNps = months.map(m => {
      const arr = mapNps[m]||[]; const avg10 = arr.length ? Math.round(arr.reduce((a,b)=>a+b,0)/arr.length) : 0; return avg10*10; // scale to 0-100
    });
    const seriesCs = months.map(m => {
      const arr = mapCs[m]||[]; const avg10 = arr.length ? Math.round(arr.reduce((a,b)=>a+b,0)/arr.length) : 0; return avg10*10; // scale to 0-100
    });
    const seriesSla = months.map(m => {
      const arr = mapSla[m]||[]; return arr.length ? Math.round(arr.reduce((a,b)=>a+b,0)/arr.length) : 0;
    });
    const datasets = [
      { label:'SLA', data: seriesSla, fill:false, borderColor: upColor, backgroundColor:'rgba(0,159,66,0.12)', borderWidth:3, pointRadius:3, pointHoverRadius:5, tension:0.25 },
      { label:'CS',  data: seriesCs,  fill:false, borderColor: '#ffc900', backgroundColor:'rgba(255,201,0,0.12)', borderWidth:3, pointRadius:3, pointHoverRadius:5, tension:0.25 },
      { label:'NPS', data: seriesNps, fill:false, borderColor: neutralColor, backgroundColor:'rgba(11,99,183,0.12)', borderWidth:3, pointRadius:3, pointHoverRadius:5, tension:0.25 }
    ];
    const options = { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label:(ctx)=> `${ctx.dataset.label}: ${ctx.parsed.y??0}%` } } }, scales:{ y:{ beginAtZero:true, max:100, ticks:{ stepSize:20, callback:v=> v+'%' } } } };
    chartIndicadores = new Chart(ctx, { type:'line', data:{ labels, datasets }, options });
    try { animateChartRender('chartIndicadores'); } catch(e){}
    return;
  }

  if(indicadorAtual === 'nps'){
    const mesesMap = {};
    (base||[]).forEach(cli=>{ if(cli.dataFmt && !isNaN(Number(cli.nps))){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(Number(cli.nps)); } });
    meses = Object.keys(mesesMap).sort();
    series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
    labelsFmt = meses.map(formatMesAno);
    labelText = 'NPS MÃ©dio';
    yScaleMax = 10;
    tooltipPrefix = 'NPS: ';
  } else if(indicadorAtual === 'cs'){
    const mesesMap = {};
    (base||[]).forEach(cli=>{ if(cli.dataFmt && !isNaN(Number(cli.cs))){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(Number(cli.cs)); } });
    meses = Object.keys(mesesMap).sort();
    series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
    labelsFmt = meses.map(formatMesAno);
    labelText = 'CS MÃ©dio';
    yScaleMax = 10;
    tooltipPrefix = 'CS: ';
  } else if(indicadorAtual === 'sla'){
    const mesesMap = {};
    (base||[]).forEach(cli => {
      if(!cli.dataFmt) return;
      const t1 = Number(cli.sla1ok)||0, f1 = Number(cli.sla1off)||0, t2 = Number(cli.sla2ok)||0, f2 = Number(cli.sla2off)||0;
      const p1 = (t1+f1) > 0 ? (t1/(t1+f1)) : null;
      const p2 = (t2+f2) > 0 ? (t2/(t2+f2)) : null;
      const pct = (p1!=null && p2!=null) ? Math.round(((p1+p2)/2)*100) : (p1!=null ? Math.round(p1*100) : (p2!=null ? Math.round(p2*100) : null));
      if(pct==null) return;
      if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
      mesesMap[cli.dataFmt].push(pct);
    });
    meses = Object.keys(mesesMap).sort();
    series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
    labelsFmt = meses.map(formatMesAno);
    labelText = 'SLA (%)';
    yScaleMax = 100;
    tooltipPrefix = 'SLA: ';
    tooltipSuffix = '%';
  } else if(indicadorAtual === 'chs'){
    const mesesMap = {};
    (base||[]).forEach(cli=>{ if(cli.dataFmt && !isNaN(Number(cli.chs))){ if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt]=[]; mesesMap[cli.dataFmt].push(Number(cli.chs)); } });
    meses = Object.keys(mesesMap).sort();
    series = meses.map(m => Math.round(mesesMap[m].reduce((a,b)=>a+b,0)/mesesMap[m].length));
    labelsFmt = meses.map(formatMesAno);
    labelText = 'CHS MÃ©dio';
    yScaleMax = 100;
    tooltipPrefix = 'CHS: ';
  } else { // 'neg' (Av Negativa)
    const mesesMap = {};
    (base||[]).forEach(cli=>{
      if(!cli.dataFmt) return;
      let raw = (cli.neg !== undefined ? cli.neg : null);
      if(raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.negativas !== undefined ? cli.negativas : raw);
      if(raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.avNeg !== undefined ? cli.avNeg : raw);
      if(raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.av_neg !== undefined ? cli.av_neg : raw);
      if(raw === null || raw === '' || isNaN(Number(raw))) raw = (cli.avNegFresh !== undefined ? cli.avNegFresh : raw);
      let val = null;
      if(raw !== null && raw !== undefined){
        const s = String(raw).replace(',', '.').replace(/[^0-9.\-]/g,'');
        const n = parseFloat(s);
        if(!isNaN(n)) val = n;
      }
      if(val === null) return;
      if(!mesesMap[cli.dataFmt]) mesesMap[cli.dataFmt] = [];
      mesesMap[cli.dataFmt].push(val);
    });
    meses = Object.keys(mesesMap).sort();
    series = meses.map(m => mesesMap[m].reduce((a,b)=>a+b,0));
    labelsFmt = meses.map(formatMesAno);
    labelText = 'AvaliaÃ§Ãµes Negativas (Qtd)';
    const maxVal = series.reduce((m,v)=> Math.max(m, v||0), 0);
    yScaleMax = Math.max(5, Math.ceil(maxVal * 1.4));
    tooltipPrefix = 'Negativas: ';
    invertColors = true;
  }

  const diffs = series.map((v,i)=> i===0 ? 0 : v - series[i-1]);
  const pointBg = diffs.map(d => invertColors ? (d>0 ? downColor : (d<0 ? upColor : neutralColor)) : (d>0 ? upColor : (d<0 ? downColor : neutralColor)) );

  const dataset = {
    label: labelText,
    data: series,
    fill: true,
    backgroundColor: cyanFill,
    borderColor: neutralColor,
    pointBackgroundColor: pointBg,
    pointBorderColor: '#fff',
    pointBorderWidth: 2,
    pointRadius: 4,
    pointHoverRadius: 6,
    borderWidth: 3,
    segment: { borderColor: ctx=>{ const dy=ctx.p1.parsed.y-ctx.p0.parsed.y; const up = invertColors ? downColor : upColor; const down = invertColors ? upColor : downColor; return dy>0?up:(dy<0?down:neutralColor); } }
  };

  const tooltipLabel = (context)=>{
    const i=context.dataIndex; const val=context.parsed.y; if(i===0) return `${tooltipPrefix}${val}${tooltipSuffix}`;
    const prevCal=previousMonthString(meses[i]); if(meses[i-1]!==prevCal) return `${tooltipPrefix}${val}${tooltipSuffix}`;
    const d=val - series[i-1]; const arrow=d>0?'â–²':(d<0?'â–¼':'â€”'); const signVal=d>0?`+${d}`:`${d}`; return `${tooltipPrefix}${val}${tooltipSuffix}  (${arrow} ${signVal} vs mÃªs anterior)`;
  };

  const options = {
    responsive:true,
    maintainAspectRatio:false,
    plugins:{ legend:{display:true}, tooltip:{ callbacks:{ label: tooltipLabel } } },
    scales:{ y:{ beginAtZero:true, max: yScaleMax } }
  };

  chartIndicadores = new Chart(ctx, { type:'line', data:{ labels: labelsFmt, datasets:[dataset] }, options });
  try { animateChartRender('chartIndicadores'); } catch(e){}
}

function toggleIndicatorFiltersMenu(){
  const menu = document.getElementById('indicatorFiltersMenu');
  if(!menu) return;
  const isOpen = menu.style.display === 'block';
  menu.style.display = isOpen ? 'none' : 'block';
  menu.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
}
function closeIndicatorFiltersMenu(){
  const menu = document.getElementById('indicatorFiltersMenu');
  if(menu){ menu.style.display = 'none'; menu.setAttribute('aria-hidden','true'); }
}
function applyIndicatorFilter(kind){
  indicadorAtual = kind;
  const title = document.getElementById('indicadorTitle');
  if(title){
    if(kind==='nps') title.textContent = 'EvoluÃ§Ã£o NPS (por MÃªs)';
    else if(kind==='sla') title.textContent = 'EvoluÃ§Ã£o SLA (%) por MÃªs';
    else if(kind==='neg') title.textContent = 'EvoluÃ§Ã£o AvaliaÃ§Ã£o Negativa (por MÃªs)';
    else if(kind==='cs') title.textContent = 'EvoluÃ§Ã£o PercepÃ§Ã£o CS (por MÃªs)';
    else if(kind==='chs') title.textContent = 'EvoluÃ§Ã£o CHS (por MÃªs)';
  }
  createChartIndicadores();
  closeIndicatorFiltersMenu();
}

/* Rankings helper functions */
function renderRankingPiores(){
  const view = getViewList();
  let piores = [...view].sort((a,b)=>a.chs-b.chs).slice(0,5);
  let list=document.getElementById('rankingPioresList'); if(list) list.innerHTML='';
  piores.forEach((cli,i)=>{
    let li=document.createElement('li');
    li.onclick = () => abrirClienteModal(cli.nome);
    const statusObj = getStatusCHS(cli.chs);
    let grad;
    if(statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
    else if(statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
    else grad = redGradientForCHS(cli.chs);
    const rankColor = statusObj.cor || '#e53935';
    const medal = (i===0 ? ' gold' : (i===1 ? ' silver' : (i===2 ? ' bronze' : '')));
    const meterW = Math.max(0, Math.min(Number(cli.chs)||0, 100));
    li.innerHTML=`<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="color:${rankColor};border-color:${rankColor};background:var(--tryvia-white);">${i+1}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}</span><span class="score" style="background:${grad};color:#fff;">${cli.chs}</span>`;
    if(list) list.appendChild(li);
  });
}
function renderRankingMelhores(){
  const view = getViewList();
  let melhores = [...view].sort((a,b)=>b.chs-a.chs).slice(0,5);
  let list=document.getElementById('rankingMelhoresList'); if(list) list.innerHTML='';
  melhores.forEach((cli,i)=>{
    let li=document.createElement('li');
    li.onclick = () => abrirClienteModal(cli.nome);
    const statusObj = getStatusCHS(cli.chs);
    let grad;
    if(statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
    else if(statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
    else grad = redGradientForCHS(cli.chs);
    const rankColor = statusObj.cor || '#009f42';
    const medal = (i===0 ? ' gold' : (i===1 ? ' silver' : (i===2 ? ' bronze' : '')));
    const meterW = Math.max(0, Math.min(Number(cli.chs)||0, 100));
    li.innerHTML=`<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="color:${rankColor};border-color:${rankColor};background:var(--tryvia-white);">${i+1}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}</span><span class="score" style="background:${grad};color:#fff;">${cli.chs}</span>`;
    if(list) list.appendChild(li);
  });
}
function renderRankingGeral(){
  const list=document.getElementById('rankingGeralList'); if(list) list.innerHTML='';
  const view = getViewList();

  // Enrich view items with trend diff (per cliente):
  // - Se currentMes !== 'all': usa exatamente currentMes e previousMonthString(currentMes).
  // - Se currentMes === 'all': para cada cliente, usa o Ãºltimo mÃªs disponÃ­vel desse cliente e o mÃªs anterior dele.
  const enriched = (view||[]).map(item => {
    let targetMonth = null;
    let prevMonth = null;
    if(currentMes && currentMes !== 'all'){
      targetMonth = normalizeYYYYMM(currentMes);
      prevMonth = previousMonthString(targetMonth);
    } else {
      // pegar Ãºltimo mÃªs disponÃ­vel para este cliente
      const monthsForClient = Array.from(new Set((clientes||[])
        .filter(r => r.nome === item.nome && r.dataFmt)
        .map(r => normalizeYYYYMM(r.dataFmt))))
        .sort();
      const len = monthsForClient.length;
      targetMonth = len ? monthsForClient[len - 1] : null;
      // para "Todos": usar mÃªs anterior disponÃ­vel do prÃ³prio cliente, nÃ£o o anterior de calendÃ¡rio
      prevMonth = len >= 2 ? monthsForClient[len - 2] : null;
    }
    // Use the same CHS shown in the list for the target month to keep delta consistent
    const chsTarget = (currentMes && currentMes !== 'all') ? (typeof item.chs === 'number' ? item.chs : null)
                       : (targetMonth ? getCHSForClientInMonth(item.nome, targetMonth) : null);
    const chsPrev = prevMonth ? getCHSForClientInMonth(item.nome, prevMonth) : null;
    let diff = null;
    if(typeof chsTarget === 'number' && typeof chsPrev === 'number') diff = Math.round(chsTarget - chsPrev);
    return Object.assign({}, item, { _trendDiff: diff, _chsTarget: chsTarget, _chsPrev: chsPrev, _targetMonth: targetMonth, _prevMonth: prevMonth });
  });

  // Apply trend filter if set
  let filtered = enriched;
  if(rankingTrendState === 'down'){
    // keep only those with diff < 0
    filtered = enriched.filter(it => typeof it._trendDiff === 'number' && it._trendDiff < 0);
  } else if(rankingTrendState === 'up'){
    filtered = enriched.filter(it => typeof it._trendDiff === 'number' && it._trendDiff > 0);
  } else {
    filtered = enriched;
  }

  // Use rankingOrderDesc to decide sort order
  const sorted = filtered.sort((a,b)=> rankingOrderDesc ? (b.chs - a.chs) : (a.chs - b.chs) );
  const totalItems = sorted.length;
  // If Ranking Geral is fullscreen, enforce at least 10 items per page locally
  const rgElFS = (function(){ try{ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null; }catch(e){ return null; } })();
  const rgEl = (function(){ try{ return document.getElementById('rankingGeral'); }catch(e){ return null; } })();
  const effectivePageSize = (rgElFS && rgEl && rgElFS === rgEl) ? Math.max(10, rankingPageSize) : rankingPageSize;
  const totalPages = Math.max(1, Math.ceil(totalItems / effectivePageSize));
  if (rankingPage > totalPages) rankingPage = totalPages;
  if (rankingPage < 1) rankingPage = 1;
  const startIdx = (rankingPage - 1) * effectivePageSize;
  const pageItems = sorted.slice(startIdx, startIdx + effectivePageSize);

  pageItems.forEach((cli, idx) => {
    const globalIndex = startIdx + idx + 1;
    const li = document.createElement('li');
    li.setAttribute('data-name', cli.nome);

    const statusObj = getStatusCHS(cli.chs);
    let grad;
    if(statusObj.cls === 'saude') grad = greenGradientForCHS(cli.chs);
    else if(statusObj.cls === 'atencao') grad = yellowGradientForCHS(cli.chs);
    else grad = redGradientForCHS(cli.chs);

    // Determine CHS delta vs previous month
    let deltaHtml = '';
    try{
      if(typeof cli._trendDiff === 'number'){
        const diff = cli._trendDiff;
        if(diff > 0){
          // Up: green arrow and value
          deltaHtml = `<span class="delta-badge delta-up" title="Subiu ${diff} pontos vs ${formatMesAno(cli._prevMonth)}">â–² ${diff}</span>`;
        } else if(diff < 0){
          deltaHtml = `<span class="delta-badge delta-down" title="Desceu ${Math.abs(diff)} pontos vs ${formatMesAno(cli._prevMonth)}">â–¼ ${Math.abs(diff)}</span>`;
        } else {
          deltaHtml = `<span class="delta-badge delta-neutral" title="Sem variaÃ§Ã£o vs ${formatMesAno(cli._prevMonth)}">â€” 0</span>`;
        }
      } else {
        deltaHtml = '';
      }
    }catch(e){ deltaHtml = ''; }

    const rankStyle = `background:var(--tryvia-white);color:${statusObj.cor};border-color:${statusObj.cor};`;
    const scoreStyle = `background: ${grad}; color:#fff;`;
    const medal = (globalIndex===1 ? ' gold' : (globalIndex===2 ? ' silver' : (globalIndex===3 ? ' bronze' : '')));
    const meterW = Math.max(0, Math.min(Number(cli.chs)||0, 100));
    li.innerHTML = `<div class="perf-meter" style="width:${meterW}%;"></div><span class="rank${medal}" style="${rankStyle}">${globalIndex}</span><span class="client" title="${escapeHtml(cli.nome)}">${escapeHtml(cli.nome)}${deltaHtml}</span><span class="score score-gold" style="${scoreStyle}">${cli.chs}</span>`;
    li.addEventListener('click', function(ev){ abrirClienteModal(cli.nome); ev.stopPropagation(); });
    const clientSpan = li.querySelector('.client');
    if (clientSpan) clientSpan.addEventListener('click', function(ev){ ev.stopPropagation(); abrirClienteModal(cli.nome); });
    if(list) list.appendChild(li);
  });
  const pageInfo = document.getElementById('rankingPageInfo');
  const prevBtn = document.getElementById('rankingPrevBtn');
  const nextBtn = document.getElementById('rankingNextBtn');
  const pagWrap = document.querySelector('#rankingGeral .ranking-pagination');
  if (pageInfo) pageInfo.textContent = `${rankingPage} / ${totalPages}`;
  if (prevBtn) prevBtn.disabled = (rankingPage <= 1);
  if (nextBtn) nextBtn.disabled = (rankingPage >= totalPages);
  if (pagWrap) pagWrap.style.display = (totalPages > 1 ? 'flex' : 'none');
  if (totalItems === 0) {
    if(list) list.innerHTML = '<li style="justify-content:center;background:transparent;border:none;color:var(--tryvia-dark2);font-weight:600;">Nenhum cliente importado.</li>';
    if (pageInfo) pageInfo.textContent = '0 / 0';
    if (prevBtn) prevBtn.disabled = true;
    if (nextBtn) nextBtn.disabled = true;
  }
}

/* New: toggleRankingOrder flips rankingOrderDesc and updates button text/icon and re-renders */
function toggleRankingOrder(){
  rankingOrderDesc = !rankingOrderDesc;
  const btn = document.getElementById('rankingOrderBtn');
  if(btn){
    btn.textContent = rankingOrderDesc ? 'â¬‡ï¸' : 'â¬†ï¸';
    btn.title = rankingOrderDesc ? 'OrdenaÃ§Ã£o: maiores primeiro (clique para inverter)' : 'OrdenaÃ§Ã£o: menores primeiro (clique para inverter)';
  }
  rankingPage = 1;
  renderRankingGeral();
}

/* New: toggleRankingTrend cycles through 'all' -> 'down' -> 'up' -> 'all' and updates button symbol/title */
function toggleRankingTrend(){
  const btn = document.getElementById('rankingTrendBtn');
  if(!btn) return;
  if(rankingTrendState === 'all'){
    rankingTrendState = 'down';
    btn.textContent = 'â†“';
    btn.title = 'Mostrar apenas Em Queda (descendo vs mÃªs anterior)';
  } else if(rankingTrendState === 'down'){
    rankingTrendState = 'up';
    btn.textContent = 'â†‘';
    btn.title = 'Mostrar apenas Em Alta (subindo vs mÃªs anterior)';
  } else {
    rankingTrendState = 'all';
    btn.textContent = 'â†•';
    btn.title = 'Filtro tendÃªncia: Todos (reset)';
  }
  rankingPage = 1;
  renderRankingGeral();
}

/* New: unified filters menu for Ranking Geral */
function toggleRankingFiltersMenu(){
  const menu = document.getElementById('rankingFiltersMenu');
  if(!menu) return;
  const isOpen = menu.style.display === 'block';
  menu.style.display = isOpen ? 'none' : 'block';
  menu.setAttribute('aria-hidden', isOpen ? 'true' : 'false');
}
function closeRankingFiltersMenu(){
  const menu = document.getElementById('rankingFiltersMenu');
  if(menu){ menu.style.display = 'none'; menu.setAttribute('aria-hidden','true'); }
}
function applyRankingFilter(type){
  if(type === 'up'){
    rankingTrendState = 'up';
  } else if(type === 'down'){
    rankingTrendState = 'down';
  } else if(type === 'asc'){
    rankingOrderDesc = false; // crescente
    rankingTrendState = 'all'; // mostrar todos os clientes
  } else if(type === 'desc'){
    rankingOrderDesc = true; // decrescente
    rankingTrendState = 'all'; // mostrar todos os clientes
  }
  rankingPage = 1;
  renderRankingGeral();
  closeRankingFiltersMenu();
}

/* Client modal and other helpers */
/* IMPORTANT: ensure modal aggregation for mes === 'all' uses the SAME aggregation method as the main view.
   Main view (when mes === 'all') uses aggregateByName(...) which computes chs as the mean of per-record chs.
   The modal will now return the same aggregated values when mes === 'all', so both show the same number.
   Additionally: when gestor/celular/agente missing, we try to reuse values from previous month, then next, then any.
*/
function parseYYYYMM(ym){
  if(!ym) return null;
  const parts = ym.split('-');
  if(parts.length<2) return null;
  const y = parseInt(parts[0],10);
  const m = parseInt(parts[1],10);
  if(isNaN(y)||isNaN(m)) return null;
  return { y, m, num: y*12 + m };
}

function findNearestRowWithGestor(rowsAll, targetMes){
  if(!rowsAll || !rowsAll.length) return null;
  // prefer previous month rows with any of gestor/celular/agente; then next month; then any with any
  const withAny = rowsAll.filter(r => (r.gestor && r.gestor.toString().trim()) || (r.celular && r.celular.toString().trim()) || (r.agente && r.agente.toString().trim()));
  if(!withAny.length) return null;

  if(!targetMes){
    // no specific month target -> prefer latest row with any
    const sorted = withAny.slice().filter(r=>r.dataFmt).sort((a,b)=>{
      const pa = parseYYYYMM(a.dataFmt), pb = parseYYYYMM(b.dataFmt);
      return (pb && pb.num || 0) - (pa && pa.num || 0);
    });
    return sorted.length ? sorted[0] : withAny[0];
  }
  const target = parseYYYYMM(targetMes);
  if(!target) {
    const any = withAny.slice().reverse().find(r => (r.gestor && r.gestor.toString().trim()) || (r.celular && r.celular.toString().trim()) || (r.agente && r.agente.toString().trim()));
    return any || null;
  }
  const candidates = withAny.map(r => {
    const parsed = parseYYYYMM(r.dataFmt || '');
    return { row: r, num: parsed ? parsed.num : null };
  });

  // previous: those with num < target.num, pick max num
  const prev = candidates.filter(c => c.num !== null && c.num < target.num).sort((a,b)=>b.num - a.num);
  if(prev.length) return prev[0].row;
  // next: those with num > target.num, pick min num
  const next = candidates.filter(c => c.num !== null && c.num > target.num).sort((a,b)=>a.num - b.num);
  if(next.length) return next[0].row;
  // fallback: any with data
  return candidates.length ? candidates[0].row : null;
}

function getAggregatedClientDataByNameAndMonth(name, mes) {
  const rowsAll = (clientes || []).filter(c => c.nome === name);
  if(!rowsAll.length) return null;
  // If asking for a specific month, aggregate only those rows (and if none for that month, fallback to all)
  if(mes && mes !== 'all') {
    let rows = rowsAll.filter(r => r.dataFmt === mes);
    if(rows.length === 0) rows = rowsAll;
    const cnt = rows.length;
    const agg = {
      nome: name,
      cs: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.cs))?0:Number(r.cs)),0)/cnt),
      nps: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.nps))?0:Number(r.nps)),0)/cnt),
      neg: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.neg))?0:Number(r.neg)),0)/cnt),
      sla1ok: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.sla1ok))?0:Number(r.sla1ok)),0)/cnt),
      sla1off: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.sla1off))?0:Number(r.sla1off)),0)/cnt),
      sla2ok: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.sla2ok))?0:Number(r.sla2ok)),0)/cnt),
      sla2off: Math.round(rows.reduce((s,r)=>s + (isNaN(Number(r.sla2off))?0:Number(r.sla2off)),0)/cnt),
      gestor: rows[0].gestor || '',
      celular: rows[0].celular || '',
      agente: rows[0].agente || ''
    };
    // If gestor/celular/agente missing, try to find nearest month with any of those fields and reuse
    if((!agg.gestor || !agg.gestor.toString().trim()) || (!agg.celular || !agg.celular.toString().trim()) || (!agg.agente || !agg.agente.toString().trim())){
      const nearest = findNearestRowWithGestor(rowsAll, mes);
      if(nearest){
        agg.gestor = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : (nearest.gestor || agg.gestor);
        agg.celular = agg.celular && agg.celular.toString().trim() ? agg.celular : (nearest.celular || agg.celular);
        agg.agente = agg.agente && agg.agente.toString().trim() ? agg.agente : (nearest.agente || agg.agente);
      }
    }
    // For modal consistency with rankings in month view, use mean of per-record CHS for the selected month
    const chsMean = Math.round(rows.reduce((s,r)=> s + (Number(r.chs)||0),0)/cnt);
    agg.chs = Math.max(0, Math.min(100, chsMean));
    return agg;
  } else {
    // mes === 'all' -> use same aggregation as main page (mean of per-record chs)
    const aggList = aggregateByName(rowsAll || []);
    const found = aggList.find(a => a.nome === name);
    if(found) {
      // If gestor/celular/agente missing in aggregated found, try to pick latest available from rowsAll
      if((!found.gestor || !found.gestor.toString().trim()) || (!found.celular || !found.celular.toString().trim()) || (!found.agente || !found.agente.toString().trim())){
        const nearest = findNearestRowWithGestor(rowsAll, null);
        if(nearest){
          found.gestor = found.gestor && found.gestor.toString().trim() ? found.gestor : (nearest.gestor || found.gestor);
          found.celular = found.celular && found.celular.toString().trim() ? found.celular : (nearest.celular || found.celular);
          found.agente = found.agente && found.agente.toString().trim() ? found.agente : (nearest.agente || found.agente);
        }
      }
      return found;
    }
    // fallback: compute averages similarly
    const cnt = rowsAll.length;
    const agg = {
      nome: name,
      cs: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.cs))?0:Number(r.cs)),0)/cnt),
      nps: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.nps))?0:Number(r.nps)),0)/cnt),
      neg: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.neg))?0:Number(r.neg)),0)/cnt),
      sla1ok: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.sla1ok))?0:Number(r.sla1ok)),0)/cnt),
      sla1off: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.sla1off))?0:Number(r.sla1off)),0)/cnt),
      sla2ok: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.sla2ok))?0:Number(r.sla2ok)),0)/cnt),
      sla2off: Math.round(rowsAll.reduce((s,r)=>s + (isNaN(Number(r.sla2off))?0:Number(r.sla2off)),0)/cnt),
      gestor: rowsAll[0].gestor || '',
      celular: rowsAll[0].celular || '',
      agente: rowsAll[0].agente || ''
    };
    // Try fallback nearest if fields missing
    if((!agg.gestor || !agg.gestor.toString().trim()) || (!agg.celular || !agg.celular.toString().trim()) || (!agg.agente || !agg.agente.toString().trim())){
      const nearest = findNearestRowWithGestor(rowsAll, null);
      if(nearest){
        agg.gestor = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : (nearest.gestor || agg.gestor);
        agg.celular = agg.celular && agg.celular.toString().trim() ? agg.celular : (nearest.celular || agg.celular);
        agg.agente = agg.agente && agg.agente.toString().trim() ? agg.agente : (nearest.agente || agg.agente);
      }
    }
    // To make it consistent with main dashboard aggregated chs, compute chs as mean of per-record chs
    agg.chs = Math.round(rowsAll.reduce((s,r)=>s + (Number(r.chs)||0),0)/cnt);
    return agg;
  }
}

function abrirClienteModal(nomeCliente) {
  const modal = document.getElementById('clienteModal');
  const rows = (clientes || []).filter(c => c.nome === nomeCliente);
  const meses = Array.from(new Set(rows.map(r=>r.dataFmt).filter(Boolean))).sort();
  let mesOptions = `<option value="all">Todos</option>`;
  meses.forEach(m=> mesOptions += `<option value="${m}">${formatMesAno(m)}</option>`);

  modal.innerHTML = `
    <div class="cliente-modal-box" role="dialog" aria-modal="true">
      <button class="close-modal" onclick="fecharClienteModal()">Fechar</button>
      <div class="cliente-modal-header">
        <div style="display:flex;align-items:center;gap:10px;">
          <h2 style="color:var(--tryvia-cyan);margin:0;">${escapeHtml(nomeCliente)}</h2>
          <div class="date-field" style="margin-left:6px;">
            <span class="calendar-icon">ðŸ“…</span>
            <select id="clientModalMesSelect" class="client-modal-mes" onchange="updateClienteModal('${escapeHtml(nomeCliente)}', this.value)">${mesOptions}</select>
          </div>
        </div>
        
      </div>

      <div class="cliente-modal-body" style="display:flex;gap:12px;align-items:flex-start;">
        <div class="cliente-modal-left" style="flex:1;min-width:220px;">
          <div id="clienteStatusLargeContainer" style="margin:0 0 8px 0;"></div>
          <div class="cliente-notas" id="clienteNotasArea" style="display:flex;gap:.6rem;justify-content:space-between;margin:.8rem 0 .8rem 0;flex-wrap:wrap;">
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">SLA</div>
              <div id="notaSLA" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipSLA">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">NPS</div>
              <div id="notaNPS" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipNPS">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">NEG</div>
              <div id="notaNEG" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipNEG">--</div>
            </div>
            <div class="nota-rect" style="padding:.6rem .45rem;min-width:120px;border-radius:10px;font-weight:700;border:2px solid var(--tryvia-cyan);box-shadow:var(--tryvia-card-shadow);text-align:center;background:var(--tryvia-cyan-bg);transition:all .2s ease;font-size:.95rem;">
              <div style="font-size:0.78rem;color:var(--tryvia-cyan);">CS</div>
              <div id="notaCS" style="font-size:1.05rem;">--</div>
              <div class="nota-tooltip" id="tooltipCS">--</div>
            </div>
          </div>

          <div class="cliente-dados-gestor" id="clienteDadosGestor" style="margin-top:0.8rem;padding:.8rem;border-radius:10px;font-size:0.95rem;background:var(--tryvia-cyan-bg);border:2px solid var(--tryvia-cyan);"></div>
          <div id="planoAcaoBtnWrap" class="plano-acao-trigger"></div>

        </div>

        <div class="cliente-modal-right" style="flex:1;min-width:220px;display:flex;flex-direction:column;gap:8px;">
          <h4 style="color:var(--tryvia-cyan);margin:0 0 6px 0;">GrÃ¡ficos</h4>
          <div style="background:var(--tryvia-white);border-radius:8px;padding:6px;border:1px solid var(--tryvia-border);box-shadow:var(--tryvia-card-shadow);">
            <div class="chart-title"><span class="dot"></span> CHS do Cliente</div>
            <canvas id="clienteChartDonut" style="width:100%;height:160px;"></canvas>
          </div>
          <div style="margin-top:6px;background:var(--tryvia-white);border-radius:8px;padding:6px;border:1px solid var(--tryvia-border);box-shadow:var(--tryvia-card-shadow);">
            <div class="chart-title"><span class="dot"></span> PontuaÃ§Ãµes por critÃ©rio</div>
            <canvas id="clienteChartComp" style="width:100%;height:160px;"></canvas>
          </div>
        </div>
      </div>
    </div>
  `;
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden','false');
  lockBodyScroll();
  modal.classList.remove('fade-out');
  modal.classList.add('fade-in');
  try {
    const select = document.getElementById('clientModalMesSelect');
    const availableMeses = meses || [];
    const defaultMonth = (currentMes && currentMes !== 'all' && availableMeses.includes(currentMes)) ? currentMes : 'all';
    if(select) { select.value = defaultMonth; }
    const onEnd = function(ev){
      if(ev.target !== modal) return;
      modal.removeEventListener('animationend', onEnd);
      if(modal.classList.contains('fade-in')) modal.classList.remove('fade-in');
      try {
        updateClienteModal(nomeCliente, (select && select.value) ? select.value : defaultMonth);
        const top = modal.querySelector('.cliente-modal-box'); if(top) top.scrollTop = 0;
      } catch(e){ updateClienteModal(nomeCliente, 'all'); }
    };
    modal.addEventListener('animationend', onEnd);
  } catch(e){ setTimeout(function(){ updateClienteModal(nomeCliente, 'all'); }, 260); }
}

function updateClienteModal(nomeCliente, mes){
  const agg = getAggregatedClientDataByNameAndMonth(nomeCliente, mes);
  if(!agg) return;

  // compute component scores
  const slaScore = calcSLA(agg);
  const npsScore = calcNPS(agg, agg.nps);
  const negScore = calcNeg(agg);
  const csScore  = calcCS(agg, agg.cs);

  // Display "score / max" beside each indicator as requested
  const notaSLAEl = document.getElementById('notaSLA');
  const notaNPSEl = document.getElementById('notaNPS');
  const notaNEGEl = document.getElementById('notaNEG');
  const notaCSEl  = document.getElementById('notaCS');

  if(notaSLAEl) notaSLAEl.textContent = `${slaScore}/${MAX_SLA}`;
  if(notaNPSEl) notaNPSEl.textContent = `${npsScore}/${MAX_NPS}`;
  if(notaNEGEl) notaNEGEl.textContent = `${negScore}/${MAX_NEG}`;
  if(notaCSEl)  notaCSEl.textContent  = `${csScore}/${MAX_CS}`;

  // Build tooltip texts showing raw/unweighted values and description, expanded and more descriptive for clarity.
  try {
    // SLA raw percent calculation (more detailed info)
    let slaTooltipText = 'SLA: sem registros suficientes';
    try {
      const s1ok = Number(agg.sla1ok), s1off = Number(agg.sla1off), s2ok = Number(agg.sla2ok), s2off = Number(agg.sla2off);
      let pct1 = (s1ok + s1off) > 0 ? (s1ok / (s1ok + s1off)) : null;
      let pct2 = (s2ok + s2off) > 0 ? (s2ok / (s2ok + s2off)) : null;
      let avgPct = null;
      if(pct1 === null && pct2 === null) avgPct = null;
      else if(pct1 === null) avgPct = pct2;
      else if(pct2 === null) avgPct = pct1;
      else avgPct = (pct1 + pct2) / 2;
      if(avgPct === null) slaTooltipText = 'SLA: sem registros suficientes para calcular percentual.';
      else {
        const pct1txt = pct1 === null ? 'â€”' : ( (pct1*100).toFixed(1) + '%' );
        const pct2txt = pct2 === null ? 'â€”' : ( (pct2*100).toFixed(1) + '%' );
        slaTooltipText = `SLA: ${ (avgPct*100).toFixed(1) }% (mÃ©dia entre 1Âª resposta e resoluÃ§Ã£o) â€” Detalhes: 1Âª resposta ${pct1txt}, resoluÃ§Ã£o ${pct2txt} â€” Nota Final: ${slaScore}/${MAX_SLA} (apos penalizaÃ§Ãµes)`;
        // Note: we build a single line description separated by " â€” " to favor horizontal layout.
      }
    } catch(e) { slaTooltipText = 'SLA: erro ao calcular detalhes.'; }

    const npsTooltip = (agg.nps === null || agg.nps === undefined || isNaN(Number(agg.nps))) ? `NPS: sem registros â€” PontuaÃ§Ã£o: ${npsScore}/${MAX_NPS}` : `NPS: ${Number(agg.nps).toFixed(1)}  â€” Nota Final: ${npsScore}/${MAX_NPS} (Ã¡pos penalizaÃ§Ãµes)`;
    const negTooltip = (agg.neg === null || agg.neg === undefined || isNaN(Number(agg.neg))) ? `Negativas: sem registros â€” PontuaÃ§Ã£o: ${negScore}/${MAX_NEG}` : `AvaliaÃ§Ãµes Negativas Detectadas: ${Number(agg.neg).toFixed(1)} â€” Nota Final: ${negScore}/${MAX_NEG} (apÃ³s penalizaÃ§Ãµes)`;
    const csTooltip = (agg.cs === null || agg.cs === undefined || isNaN(Number(agg.cs))) ? `CS: sem registros â€” PontuaÃ§Ã£o: ${csScore}/${MAX_CS}` : `PercepÃ§Ã£o CS: ${Number(agg.cs).toFixed(1)} â€” Nota Final: ${csScore}/${MAX_CS} (apÃ³s penalizaÃ§Ãµes)`;

    const tSLA = document.getElementById('tooltipSLA');
    const tNPS = document.getElementById('tooltipNPS');
    const tNEG = document.getElementById('tooltipNEG');
    const tCS = document.getElementById('tooltipCS');
    if(tSLA) tSLA.textContent = slaTooltipText;
    if(tNPS) tNPS.textContent = npsTooltip;
    if(tNEG) tNEG.textContent = negTooltip;
    if(tCS) tCS.textContent = csTooltip;
  } catch(e){}

  // Instead of showing "Registros", now show "Agente" value (from column Agente) in the client modal
  // Use fallback logic: agg.agente should already have been filled by nearest-month logic if missing
  const agenteText = agg.agente && agg.agente.toString().trim() ? agg.agente : 'NÃ£o informado';
  const gestorText = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : 'NÃ£o informado';
  const celularText = agg.celular && agg.celular.toString().trim() ? agg.celular : 'NÃ£o informado';

  document.getElementById('clienteDadosGestor').innerHTML = `<strong>Agente:</strong> ${escapeHtml(agenteText)}<br><strong>Gestor:</strong> ${escapeHtml(gestorText)}<br><strong>Celular:</strong> ${escapeHtml(celularText)}`;

  const statusObj = getStatusCHS(agg.chs);
  const statusHtml = `<div class="status-large ${statusObj.cls}" style="display:flex;align-items:center;gap:10px;padding:10px;border-radius:12px;font-weight:800;font-size:1rem;background:${statusObj.cls==='saude'?'linear-gradient(90deg,#e7faee,#d4f4dd)':(statusObj.cls==='atencao'?'linear-gradient(90deg,#fffbe7,#fff3c6)':'linear-gradient(90deg,#ffeaea,#ffd1d1)')};color:${statusObj.cor};border:2px solid ${statusObj.cor};"><div class="status-icon" style="font-size:1.4rem;">${statusObj.cls==='saude'?'ðŸ’š':(statusObj.cls==='atencao'?'âš ï¸':'âŒ')}</div><div><div class="status-text">${statusObj.txt}</div><div class="status-chs">${agg.chs} pts</div></div></div>`;
  const statusContainer = document.getElementById('clienteStatusLargeContainer'); 
  if(statusContainer) statusContainer.innerHTML = statusHtml;

  // Show/Hide Plano de AÃ§Ã£o button: show if CHS < 70 OR cliente estÃ¡ em queda vs mÃªs anterior
  let isDownTrend = false;
  try{
    let targetMonth = null, prevMonth = null;
    if(mes && mes !== 'all'){
      targetMonth = normalizeYYYYMM(mes);
      prevMonth = previousMonthString(targetMonth);
    } else {
      const monthsForClient = Array.from(new Set((clientes||[])
        .filter(r => r.nome === nomeCliente && r.dataFmt)
        .map(r => normalizeYYYYMM(r.dataFmt)))).sort();
      const len = monthsForClient.length;
      targetMonth = len ? monthsForClient[len - 1] : null;
      prevMonth = len >= 2 ? monthsForClient[len - 2] : null;
    }
    const currVal = targetMonth ? getCHSForClientInMonth(nomeCliente, targetMonth) : null;
    const prevVal = prevMonth ? getCHSForClientInMonth(nomeCliente, prevMonth) : null;
    isDownTrend = (typeof currVal === 'number' && typeof prevVal === 'number' && currVal < prevVal);
  }catch(e){ isDownTrend = false; }

  try{
    const btnWrap = document.getElementById('planoAcaoBtnWrap');
    if(btnWrap){
      if(isDownTrend || Number(agg.chs) < 70){
        btnWrap.innerHTML = `<button class="btn btn-primary" id="planoAcaoBtn">Plano de AÃ§Ã£o</button>`;
        setTimeout(function(){ var b=document.getElementById('planoAcaoBtn'); if(b){ b.onclick = function(){ abrirPlanoAcao(nomeCliente); }; } }, 0);
      } else {
        btnWrap.innerHTML = '';
      }
    }
  }catch(e){}

  try { if(chartClienteDonut) chartClienteDonut.destroy(); } catch(e){}
  const donutCanvas = document.getElementById('clienteChartDonut');
  if(donutCanvas){ try{ donutCanvas.width = donutCanvas.clientWidth || 320; donutCanvas.height = 160; }catch(e){} }
  const donutCtx = donutCanvas.getContext('2d');
  const statusColor = statusObj.cor || '#00cfff';
  const donutData = {
    labels: ['CHS','Restante'],
    datasets: [{
      data: [Math.max(0, Math.round(agg.chs)), Math.max(0, 100 - Math.round(agg.chs))],
      backgroundColor: [statusColor, '#e9eef0'],
      borderColor: ['#ffffff','#ffffff'],
      borderWidth: 2
    }]
  };
  chartClienteDonut = new Chart(donutCtx, {
    type: 'doughnut',
    data: donutData,
    options: {
      devicePixelRatio: (window.devicePixelRatio || 1),
      responsive:false,
      maintainAspectRatio:false,
      animation: false,
      cutout: '60%',
      plugins: {
        legend: { display:false },
        tooltip: { callbacks: { label: function(context){ return context.label + ': ' + context.parsed + (context.label==='CHS' ? ' pts' : ''); } } },
        valueLabelsAll: false,
        centerText: { enabled:true, text: String(Math.max(0, Math.round(agg.chs)||0)), font: '900 30px Roboto, Arial, sans-serif', color: '#000' }
      }
    }
  });

  try { if(chartClienteComp) chartClienteComp.destroy(); } catch(e){}
  const compCanvas = document.getElementById('clienteChartComp');
  if(compCanvas){ try{ compCanvas.width = compCanvas.clientWidth || 320; compCanvas.height = 160; }catch(e){} }
  const compCtx = compCanvas.getContext('2d');
  const compData = {
    labels: ['SLA','NPS','Negativas','CS'],
    datasets: [{
      label: 'PontuaÃ§Ã£o',
      data: [calcSLA(agg), calcNPS(agg, agg.nps), calcNeg(agg), calcCS(agg, agg.cs)],
      backgroundColor: ['#007aaf','#0b63b7','#e53935','#009f42'],
      borderColor: ['#007aaf','#0b63b7','#c62828','#007a33'],
      borderWidth: 1, barPercentage: 0.95, categoryPercentage: 0.9, maxBarThickness: 44, borderRadius: 12, borderSkipped:'left'
    }]
  };
  chartClienteComp = new Chart(compCtx, {
    type: 'bar',
    data: compData,
    options: {
      devicePixelRatio: (window.devicePixelRatio || 1),
      indexAxis: 'y',
      responsive: false,
      maintainAspectRatio:false,
      animation: false,
      scales: { x: { beginAtZero:true, max: 40, ticks: { stepSize:10 } } },
      plugins: { legend: { display:false } }
    }
  });

  try{ document.getElementById('clienteChartDonut')._chart = chartClienteDonut; document.getElementById('clienteChartComp')._chart = chartClienteComp; } catch(e){}

  // New: trend charts (% de clientes em queda / em alta)
  try{ if(chartClienteTrendDown) chartClienteTrendDown.destroy(); }catch(e){}
  try{ if(chartClienteTrendUp) chartClienteTrendUp.destroy(); }catch(e){}
  const trendDownCanvas = document.getElementById('clienteTrendDown');
  const trendUpCanvas = document.getElementById('clienteTrendUp');
  if(trendDownCanvas && trendUpCanvas){
    try{ trendDownCanvas.width = trendDownCanvas.clientWidth || 320; trendDownCanvas.height = 160; }catch(e){}
    try{ trendUpCanvas.width = trendUpCanvas.clientWidth || 320; trendUpCanvas.height = 160; }catch(e){}
    const trendDownCtx = trendDownCanvas.getContext('2d');
    const trendUpCtx = trendUpCanvas.getContext('2d');

    const allMonths = Array.from(new Set((clientes||[]).map(c=>c.dataFmt).filter(Boolean))).sort();
    const allNames = Array.from(new Set((clientes||[]).map(c => (c.nome||'').toString().trim()).filter(Boolean)));
    const labelsFmt = [];
    const downPercs = [];
    const upPercs = [];
    for(let i=0;i<allMonths.length;i++){
      const m = normalizeYYYYMM(allMonths[i]);
      labelsFmt.push(formatMesAno(m));
      const prev = previousMonthString(m);
      if(!prev){ downPercs.push(0); upPercs.push(0); continue; }
      let down=0, up=0;
      for(const name of allNames){
        const prevVal = getCHSForClientInMonth(name, prev);
        const currVal = getCHSForClientInMonth(name, m);
        if(prevVal==null || currVal==null) continue;
        if(currVal < prevVal) down++; else if(currVal > prevVal) up++;
      }
      const total = allNames.length || 1;
      downPercs.push(Math.round((down/total)*1000)/10);
      upPercs.push(Math.round((up/total)*1000)/10);
    }

    chartClienteTrendDown = new Chart(trendDownCtx, {
      type: 'line',
      data: { labels: labelsFmt, datasets: [{ label: '% em queda', data: downPercs, fill:true, backgroundColor:'rgba(229,57,53,0.12)', borderColor:'#e53935', borderWidth:2.5, pointRadius:3, pointHoverRadius:5, tension:0.25 }] },
      options: { devicePixelRatio:(window.devicePixelRatio||1), responsive:false, maintainAspectRatio:false, animation:false, scales:{ y:{ beginAtZero:true, max:100, ticks:{ stepSize:20, callback:(v)=> v + '%' } }, x:{ grid:{ display:false } } }, plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label:(ctx)=> (ctx.parsed.y??0) + '%' } } } }
    });

    chartClienteTrendUp = new Chart(trendUpCtx, {
      type: 'line',
      data: { labels: labelsFmt, datasets: [{ label: '% em alta', data: upPercs, fill:true, backgroundColor:'rgba(0,159,66,0.12)', borderColor:'#009f42', borderWidth:2.5, pointRadius:3, pointHoverRadius:5, tension:0.25 }] },
      options: { devicePixelRatio:(window.devicePixelRatio||1), responsive:false, maintainAspectRatio:false, animation:false, scales:{ y:{ beginAtZero:true, max:100, ticks:{ stepSize:20, callback:(v)=> v + '%' } }, x:{ grid:{ display:false } } }, plugins:{ legend:{ display:false }, tooltip:{ callbacks:{ label:(ctx)=> (ctx.parsed.y??0) + '%' } } } }
    });
  }
}

function fecharClienteModal() {
  const modal = document.getElementById('clienteModal');
  if(modal.classList.contains('fade-in')) modal.classList.remove('fade-in');
  modal.classList.add('fade-out');
  const onEnd = function(){
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden','true');
    unlockBodyScroll();
    modal.classList.remove('fade-out');
    modal.removeEventListener('animationend', onEnd);
  };
  modal.addEventListener('animationend', onEnd);
  try{ if(chartClienteDonut) chartClienteDonut.destroy(); } catch(e){}
  try{ if(chartClienteComp) chartClienteComp.destroy(); } catch(e){}
  try{ if(chartClienteTrendDown) { chartClienteTrendDown.destroy(); chartClienteTrendDown=null; } } catch(e){}
  try{ if(chartClienteTrendUp) { chartClienteTrendUp.destroy(); chartClienteTrendUp=null; } } catch(e){}
}

/* Plano de AÃ§Ã£o: open/close and content builder */
function abrirPlanoAcao(nomeCliente){
  try{
    const sel = document.getElementById('clientModalMesSelect');
    const mes = sel ? sel.value : 'all';
    const agg = getAggregatedClientDataByNameAndMonth(nomeCliente, mes);
    if(!agg){ alert('Dados indisponÃ­veis para este cliente.'); return; }
    const gestorText = agg.gestor && agg.gestor.toString().trim() ? agg.gestor : 'NÃ£o informado';
    const agenteText = agg.agente && agg.agente.toString().trim() ? agg.agente : 'NÃ£o informado';
    const notaGeral = Math.round(Number(agg.chs)||0);

    // Sinalizadores simples por mÃ©trica
    const s1ok = Number(agg.sla1ok)||0, s1off = Number(agg.sla1off)||0, s2ok = Number(agg.sla2ok)||0, s2off = Number(agg.sla2off)||0;
    const s1tot = s1ok + s1off, s2tot = s2ok + s2off;
    const primeiraRespostaOK = s1tot>0 ? (s1ok/s1tot) : null; // proporÃ§Ã£o atendida
    const resolucaoOK = s2tot>0 ? (s2ok/s2tot) : null;        // proporÃ§Ã£o atendida
    const satisfacao = (agg.nps!=null && !isNaN(Number(agg.nps))) ? Number(agg.nps) : null; // 0-10
    const avalNegativas = (agg.neg!=null && !isNaN(Number(agg.neg))) ? Number(agg.neg) : null; // contagem
    const qualidade = (agg.cs!=null && !isNaN(Number(agg.cs))) ? Number(agg.cs) : null; // 0-10

    // CritÃ©rios (simples e claros)
    const bomPrimeiraResp = primeiraRespostaOK !== null && primeiraRespostaOK >= 0.90;
    const bomResolucao    = resolucaoOK !== null && resolucaoOK >= 0.85;
    const bomSatisfacao   = satisfacao !== null && satisfacao >= 8;
    const semNegativas    = avalNegativas !== null && avalNegativas === 0;
    const bomQualidade    = qualidade !== null && qualidade >= 8;

    const precisaPrimeiraResp = primeiraRespostaOK !== null && primeiraRespostaOK < 0.90;
    const precisaResolucao    = resolucaoOK !== null && resolucaoOK < 0.85;
    const precisaSatisfacao   = satisfacao !== null && satisfacao < 8;
    const precisaNegativas    = avalNegativas !== null && avalNegativas >= 1;
    const precisaQualidade    = qualidade !== null && qualidade < 8;

    // Destaques positivos e pontos a melhorar
    const bons = [];
    if(bomPrimeiraResp) bons.push('Primeira resposta rÃ¡pida na maior parte dos atendimentos');
    if(bomResolucao)    bons.push('ResoluÃ§Ã£o dentro do prazo na maioria dos casos');
    if(semNegativas)    bons.push('Sem avaliaÃ§Ãµes negativas recentes');
    if(bomSatisfacao)   bons.push('Boa satisfaÃ§Ã£o nas pesquisas (mÃ©dia 8 ou mais)');
    if(bomQualidade)    bons.push('Boa qualidade do atendimento');

    const melhorar = [];
    if(precisaPrimeiraResp) melhorar.push('Tempo para dar a primeira resposta');
    if(precisaResolucao)    melhorar.push('Tempo para resolver os pedidos');
    if(precisaNegativas)    melhorar.push('AvaliaÃ§Ãµes negativas recentes');
    if(precisaSatisfacao)   melhorar.push('SatisfaÃ§Ã£o do cliente nas pesquisas');
    if(precisaQualidade)    melhorar.push('Qualidade do atendimento');

    // SeÃ§Ãµes de aÃ§Ãµes especÃ­ficas (somente para o que precisa melhorar)
    const secoes = [];
    if(precisaPrimeiraResp){
      secoes.push({
        titulo: 'Tempo para responder a primeira mensagem',
        bullets: [
          'Definir meta clara para a primeira resposta (ex.: atÃ© 10 minutos em horÃ¡rio comercial).',
          'Usar mensagens salvas para agilizar a primeira resposta.',
          'Acompanhar diariamente os casos que ainda nÃ£o tiveram resposta inicial e agir de imediato.'
        ]
      });
    }
    if(precisaResolucao){
      secoes.push({
        titulo: 'Tempo para resolver o pedido',
        bullets: [
          'Criar um passo a passo simples para os problemas mais comuns (com soluÃ§Ã£o e responsÃ¡vel).',
          'Remover bloqueios rapidamente: se um caso estÃ¡ parado, envolver quem pode destravar na hora.',
          'Revisar diariamente os pedidos perto do prazo e priorizar a conclusÃ£o.'
        ]
      });
    }
    if(precisaNegativas){
      secoes.push({
        titulo: 'AvaliaÃ§Ãµes negativas',
        bullets: [
          'Entrar em contato com quem avaliou negativamente em atÃ© 2 dias para entender o motivo e combinar a soluÃ§Ã£o.',
          'Quando for pÃºblico, responder com pedido de desculpas, explicaÃ§Ã£o simples e o que serÃ¡ feito para corrigir.',
          'Toda semana, revisar com a equipe os atendimentos mal avaliados e combinar melhorias.'
        ]
      });
    }
    if(precisaSatisfacao){
      secoes.push({
        titulo: 'SatisfaÃ§Ã£o do cliente (pesquisa)',
        bullets: [
          'Ao finalizar um atendimento, confirmar se a pessoa ficou satisfeita e qual Ã© o prÃ³ximo passo.',
          'Mapear os 3 motivos mais comuns de insatisfaÃ§Ã£o e corrigi-los com prioridade.',
          'Ajustar a linguagem: mensagens curtas, claras e com prazos objetivos.'
        ]
      });
    }
    if(precisaQualidade){
      secoes.push({
        titulo: 'Qualidade do atendimento',
        bullets: [
          'Treinar a equipe nos cenÃ¡rios de uso mais comuns do cliente, com exemplos prÃ¡ticos.',
          'Criar um plano simples de acompanhamento com marcos e responsÃ¡veis.',
          'Fazer uma reuniÃ£o mensal de resultados com o cliente: o que melhorou e o que faremos no prÃ³ximo mÃªs.'
        ]
      });
    }

    const bonsHtml = bons.length ? `<ul>${bons.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>` : '<ul><li>Ainda nÃ£o temos destaques positivos claros â€” vamos construir com as aÃ§Ãµes abaixo.</li></ul>';
    const melhorarHtml = melhorar.length ? `<ul>${melhorar.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>` : '<ul><li>Nenhum ponto crÃ­tico detectado neste perÃ­odo â€” mantenha as boas prÃ¡ticas.</li></ul>';
    const secoesHtml = secoes.map(sec=> `<h4>${escapeHtml(sec.titulo)}</h4><ul>${sec.bullets.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>`).join('');

    const alvos = [];
    if(precisaPrimeiraResp) alvos.push('tempo de resposta');
    if(precisaResolucao)    alvos.push('tempo de resoluÃ§Ã£o');
    if(precisaSatisfacao)   alvos.push('satisfaÃ§Ã£o do cliente');
    if(precisaNegativas)    alvos.push('reduÃ§Ã£o de avaliaÃ§Ãµes negativas');
    if(precisaQualidade)    alvos.push('qualidade do atendimento');
    const objetivoLinha = alvos.length ? `Em 30 dias, melhorar ${escapeHtml(alvos.join(', '))} e aumentar a nota geral.` : 'Em 30 dias, manter os bons resultados e a satisfaÃ§Ã£o do cliente.';

    // Motivos (somente pontos ruins, com metas claras)
    const motivos = [];
    if(precisaPrimeiraResp && primeiraRespostaOK!==null) motivos.push(`Primeira resposta no prazo ficou em ${Math.round(primeiraRespostaOK*100)}% (meta: 90%).`);
    if(precisaResolucao && resolucaoOK!==null) motivos.push(`ResoluÃ§Ã£o no prazo ficou em ${Math.round(resolucaoOK*100)}% (meta: 85%).`);
    if(precisaSatisfacao && satisfacao!==null) motivos.push(`SatisfaÃ§Ã£o mÃ©dia ficou em ${satisfacao.toFixed(1)} (meta: 8).`);
    if(precisaNegativas && avalNegativas!==null) motivos.push(`Foram registradas ${avalNegativas} avaliaÃ§Ãµes negativas (meta: 0).`);
    if(precisaQualidade && qualidade!==null) motivos.push(`Qualidade do atendimento ficou em ${qualidade.toFixed(1)} (meta: 8).`);

    // PDCA â€“ montar bullets conforme pontos fracos
    const pdcaPlan = [];
    if(precisaPrimeiraResp) pdcaPlan.push('Definir meta de primeira resposta (ex.: atÃ© 10 minutos em horÃ¡rio comercial).');
    if(precisaResolucao)    pdcaPlan.push('Definir metas simples de prazos por tipo de pedido (fÃ¡cil, mÃ©dio, complexo).');
    if(precisaSatisfacao)   pdcaPlan.push('Estabelecer padrÃ£o de encerramento: confirmar soluÃ§Ã£o e prÃ³ximo passo.');
    if(precisaNegativas)    pdcaPlan.push('Criar regra de contato com avaliaÃ§Ãµes negativas em atÃ© 2 dias.');
    if(precisaQualidade)    pdcaPlan.push('Planejar treinamento rÃ¡pido com exemplos prÃ¡ticos do cliente.');

    const pdcaDo = [];
    if(precisaPrimeiraResp) pdcaDo.push('Usar mensagens salvas para agilizar a primeira resposta.');
    if(precisaResolucao)    pdcaDo.push('Criar passo a passo dos problemas mais comuns e definir responsÃ¡veis.');
    if(precisaSatisfacao)   pdcaDo.push('Ajustar a linguagem: mensagens curtas, claras e com prazos.');
    if(precisaNegativas)    pdcaDo.push('Responder avaliaÃ§Ãµes negativas com pedido de desculpas e plano de soluÃ§Ã£o.');
    if(precisaQualidade)    pdcaDo.push('Realizar sessÃ£o de treinamento de 1 hora com a equipe.');

    const pdcaCheck = [
      'Acompanhar diariamente: casos sem primeira resposta e casos perto do prazo.',
      'Revisar semanalmente as avaliaÃ§Ãµes e pesquisas recebidas.',
      'Registrar o que foi feito e o resultado (planilha simples ou sistema).'
    ];

    const pdcaAct = [
      'A cada semana: manter o que funcionou e ajustar o que nÃ£o funcionou.',
      'Em 30 dias: revisar as metas e atualizar o plano para o prÃ³ximo mÃªs.'
    ];

    const pdcaHtml = `
      <div class="pdca-grid">
        <div class="pdca-card pdca-plan"><div class="pdca-head"><span class="pdca-icon">ðŸ“</span> PLAN</div><ul>${pdcaPlan.map(b=>`<li>${escapeHtml(b)}</li>`).join('') || '<li>Manter boas prÃ¡ticas atuais.</li>'}</ul></div>
        <div class="pdca-card pdca-do"><div class="pdca-head"><span class="pdca-icon">â–¶ï¸</span> DO</div><ul>${pdcaDo.map(b=>`<li>${escapeHtml(b)}</li>`).join('') || '<li>Executar as aÃ§Ãµes definidas no plano.</li>'}</ul></div>
        <div class="pdca-card pdca-check"><div class="pdca-head"><span class="pdca-icon">âœ…</span> CHECK</div><ul>${pdcaCheck.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul></div>
        <div class="pdca-card pdca-act"><div class="pdca-head"><span class="pdca-icon">ðŸ”</span> ACT</div><ul>${pdcaAct.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul></div>
      </div>`;

    const html = `
      <div class="plano-acao-box">
        <button class="plano-acao-close" onclick="fecharPlanoAcao()">Fechar</button>
        <h3>Plano de AÃ§Ã£o (PDCA) â€” ${escapeHtml(nomeCliente)} (nota geral: ${notaGeral})</h3>
        <div><strong>Gestor:</strong> ${escapeHtml(gestorText)} &nbsp; | &nbsp; <strong>Agente:</strong> ${escapeHtml(agenteText)}</div>
        <h4>Por que a nota ficou assim?</h4>
        <ul>${motivos.map(m=>`<li>${escapeHtml(m)}</li>`).join('')}</ul>
        <h4>O que jÃ¡ estÃ¡ bom</h4>
        ${bonsHtml}
        <h4>Objetivo (30 dias)</h4>
        <ul><li>${objetivoLinha}</li></ul>
        ${pdcaHtml}
      </div>`;
    const overlay = document.createElement('div');
    overlay.className = 'plano-acao-overlay';
    overlay.innerHTML = html;
    try{ overlay.classList.add('fade-in'); setTimeout(function(){ overlay.classList.remove('fade-in'); }, 260); }catch(e){}
    document.body.appendChild(overlay);
  }catch(e){ alert('NÃ£o foi possÃ­vel abrir o plano de aÃ§Ã£o.'); }
}

function fecharPlanoAcao(){
  const ov = document.querySelector('.plano-acao-overlay');
  if(!ov) return;
  try{
    ov.classList.add('fade-out');
    const onEnd = function(){ ov.remove(); };
    ov.addEventListener('animationend', onEnd, { once: true });
  }catch(e){ ov.remove(); }
}

/* Help CHS modal */
function openHelpCHS(){
  try{
    const overlay = document.createElement('div');
    overlay.className = 'help-overlay';
    overlay.innerHTML = `
      <div class="help-box">
        <button class="help-close" onclick="closeHelpCHS()">Fechar</button>
        <div class="help-hero">
          <div class="hero-left">
            <div class="hero-title">ðŸ’¡ Entenda o CHS <span class="hero-sub">(Customer Health Score)</span></div>
            <div>O CHS Ã© uma nota de <strong>0 a 100</strong> que resume a saÃºde do relacionamento com o cliente. Ã‰ composto por 4 partes, com pesos diferentes.</div>
            <div class="pill-group">
              <span class="pill saude"><span class="dot"></span> SaudÃ¡vel â‰¥ 70</span>
              <span class="pill atencao"><span class="dot"></span> AtenÃ§Ã£o 40â€“69</span>
              <span class="pill critico"><span class="dot"></span> CrÃ­tico &lt; 40</span>
            </div>
          </div>
          <div class="hero-right">
            <canvas id="helpChsDonut" style="width:200px;height:200px;" width="200" height="200"></canvas>
            <div class="legend">
              <span class="legend-item legend-sla"><span class="dot"></span> SLA 20</span>
              <span class="legend-item legend-nps"><span class="dot"></span> NPS 30</span>
              <span class="legend-item legend-neg"><span class="dot"></span> Negativas 30</span>
              <span class="legend-item legend-cs"><span class="dot"></span> CS 20</span>
            </div>
          </div>
        </div>

        <div class="help-grid">
          <div class="help-tile">
            <div class="tile-icon">â±ï¸</div>
            <div>
              <h4>SLA (20 pts)</h4>
              <p>MÃ©dia entre <strong>1Âª resposta</strong> no prazo e <strong>resoluÃ§Ã£o</strong> no prazo. Quanto maior a % de atendimentos no prazo, maior a pontuaÃ§Ã£o.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">ðŸ˜Š</div>
            <div>
              <h4>NPS (30 pts)</h4>
              <p>MÃ©dia de satisfaÃ§Ã£o de <strong>0 a 10</strong>. Notas altas elevam o CHS, notas baixas reduzem.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">âŒ</div>
            <div>
              <h4>Negativas (30 pts)</h4>
              <p>Quantidade recente de avaliaÃ§Ãµes negativas. <strong>0 Ã© a meta</strong>. Quanto menos negativas, maior a pontuaÃ§Ã£o.</p>
            </div>
          </div>
          <div class="help-tile">
            <div class="tile-icon">â­</div>
            <div>
              <h4>CS (20 pts)</h4>
              <p><strong>PercepÃ§Ã£o de qualidade</strong> de 0 a 10. Reflete a experiÃªncia do cliente com o atendimento.</p>
            </div>
          </div>
        </div>

        <div class="help-section">
          <h4>Como lemos o resultado</h4>
          <ul>
            <li>Use o <strong>filtro de mÃªs</strong> para comparar perÃ­odos.</li>
            <li>Observe <strong>tendÃªncias</strong> (alta/queda) nos grÃ¡ficos.</li>
            <li>Monitore <strong>negativas</strong> â€” trabalhar para manter <strong>0</strong>.</li>
            <li>Se a nota cair, abra o <strong>Plano de AÃ§Ã£o (PDCA)</strong>.</li>
          </ul>
        </div>

        <div class="help-section">
          <h4>Exemplo rÃ¡pido</h4>
          <div>Se um cliente tem: SLA 16/20, NPS 22/30, Negativas 15/30, CS 12/20 â†’ <strong>CHS 65</strong> (AtenÃ§Ã£o). Foco em reduzir negativas e melhorar SLA.</div>
        </div>
      </div>`;
    document.body.appendChild(overlay);
    lockBodyScroll();
    // Build the donut chart for CHS composition
    try{
      const el = document.getElementById('helpChsDonut');
      if(el){
        const ctx = el.getContext('2d');
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['SLA 20','NPS 30','Negativas 30','CS 20'],
            datasets: [{ data:[20,30,30,20], backgroundColor:['#0b63b7','#6b43b8','#e53935','#009f42'], borderColor:'#ffffff', borderWidth:2 }]
          },
          options: { devicePixelRatio:(window.devicePixelRatio||1), responsive:false, maintainAspectRatio:false, cutout:'62%', plugins:{ legend:{ display:false } } }
        });
      }
    }catch(e){}
  }catch(e){ alert('NÃ£o foi possÃ­vel abrir a ajuda.'); }
}

function closeHelpCHS(){
  try{
    const ov = document.querySelector('.help-overlay');
    if(!ov) return; ov.remove();
    unlockBodyScroll();
  }catch(e){}
}
/* Helper */
function getAverageCHSForName(name){
  if(!clientes || !clientes.length) return '--';
  const rows = clientes.filter(c => c.nome === name);
  if(!rows.length) return '--';
  const avg = Math.round(rows.reduce((s,r)=>s + (Number(r.chs)||0),0)/rows.length);
  return avg;
}

/* ========== Floating filters logic and synchronization ========== */

function createFloatingFiltersIfNeeded(){
  const floatingContainer = document.getElementById('floatingFilters');
  if(!floatingContainer) return;
  if(floatingContainer.dataset.inited === '1') return;

  floatingContainer.innerHTML = `
    <div class="filters-inner" id="floatingFiltersInner">
      <div class="header-search" style="margin-left:0;">
        <span class="search-icon">ðŸ”</span>
        <input type="text" id="floatSearchInput" class="search-input" placeholder="Buscar clientes..." />
        <div id="floatSearchSuggestions" class="suggestions" role="listbox" aria-hidden="true"></div>
      </div>
      <div class="date-field" style="margin-left:6px;">
        <span class="calendar-icon">ðŸ“…</span>
        <select id="floatMesSelect" class="mes-select">
          <option value="all">Todos</option>
        </select>
      </div>
      <div style="display:flex;gap:8px;margin-left:6px;align-items:center;">
        <button class="btn" id="floatSelectBtn">Selecionar clientes</button>
        <button class="btn btn-primary" id="floatCompareBtn">Comparar</button>
        <button class="help-btn" id="floatHelpBtn" title="Entenda o CHS">?</button>
      </div>
    </div>
  `;
  floatingContainer.dataset.inited = '1';
  // Default collapsed state on creation (persisted preference honored; default collapsed if none)
  try{
    let saved = null; try{ saved = localStorage.getItem('floatingFiltersCollapsed'); }catch(e){}
    const wantCollapsed = (saved === '1' || saved === null || typeof saved === 'undefined');
    const inner = document.getElementById('floatingFiltersInner');
    if(wantCollapsed){ floatingContainer.classList.add('collapsed'); if(inner) inner.classList.add('collapsed'); }
  }catch(e){}
  try { var fh=document.getElementById('floatHelpBtn'); if(fh) fh.onclick = function(){ openHelpCHS(); }; } catch(e){}

  function syncMonthOptions(){
    try{
      const src = document.getElementById('mesSelect');
      const dst = document.getElementById('floatMesSelect');
      if(!dst) return;
      if(src){
        dst.innerHTML = src.innerHTML;
        dst.value = src.value;
      } else {
        const meses = (typeof getAllMonthsSorted === 'function') ? getAllMonthsSorted() : Array.from(new Set((clientes||[]).map(c=>c.dataFmt).filter(Boolean))).sort();
        const options = `<option value="all">Todos</option>` + meses.map(m=>`<option value="${m}">${formatMesAno(m)}</option>`).join('');
        dst.innerHTML = options;
        dst.value = (typeof currentMes !== 'undefined' && currentMes) ? currentMes : 'all';
      }
    }catch(e){}
  }
  syncMonthOptions();

  const floatSearch = document.getElementById('floatSearchInput');
  const mainSearch = document.getElementById('searchInput');
  if(floatSearch){
    floatSearch.addEventListener('input', (e)=>{
      try{ if(mainSearch && mainSearch.value !== e.target.value) mainSearch.value = e.target.value; }catch(ex){}
      filtrarClientes();
      renderCompareSelector();
      renderSelectModalList();
    });
  }
  if(mainSearch && floatSearch){
    mainSearch.addEventListener('input', (e)=>{
      try{ if(floatSearch.value !== e.target.value) floatSearch.value = e.target.value; }catch(ex){}
    });
  }

  const floatMes = document.getElementById('floatMesSelect');
  const mainMes = document.getElementById('mesSelect');
  if(floatMes){
    floatMes.addEventListener('change', (e)=>{
      if(mainMes && mainMes.value !== e.target.value) mainMes.value = e.target.value;
      onMesChange(e.target.value);
    });
  }
  if(mainMes && floatMes){
    mainMes.addEventListener('change', (e)=>{
      if(floatMes.value !== e.target.value) floatMes.value = mainMes.value;
    });
  }

  const floatSelectBtn = document.getElementById('floatSelectBtn');
  const floatCompareBtn = document.getElementById('floatCompareBtn');
  if(floatSelectBtn) floatSelectBtn.addEventListener('click', ()=>{ openSelectModal(); });
  if(floatCompareBtn) floatCompareBtn.addEventListener('click', ()=>{ openCompareSelector(); });

  const originalPopulate = populateCompareMonthSelects;
  populateCompareMonthSelects = function(){
    originalPopulate();
    syncMonthOptions();
  };

  setTimeout(()=>{ try{ if(mainSearch && floatSearch) floatSearch.value = mainSearch.value; if(mainMes && floatMes) floatMes.value = mainMes.value; }catch(e){} },50);
}

/* Init observer to show floating filters when main filters scroll out */
function initFiltersObserver(){
  const mainBar = document.getElementById('mainFiltersBar');
  const floating = document.getElementById('floatingFilters');
  if(!mainBar || !floating) return;

  createFloatingFiltersIfNeeded();

  let observer = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if(entry.isIntersecting){
        try{
          floating.style.display = 'none';
          floating.setAttribute('aria-hidden','true');
          floating.classList.remove('show');
          floating.classList.add('hide');
        }catch(e){}
      } else {
        try{
          createFloatingFiltersIfNeeded();
          floating.style.display = 'flex';
          floating.setAttribute('aria-hidden','false');
          floating.classList.remove('hide');
          floating.classList.add('show');

          // Set initial collapsed/expanded based on saved preference (default: collapsed)
          try {
            const inner = document.getElementById('floatingFiltersInner');
            let saved = null; try{ saved = localStorage.getItem('floatingFiltersCollapsed'); }catch(e){}
            const wantCollapsed = (saved === '1' || saved === null || typeof saved === 'undefined');
            if(wantCollapsed){
              floating.classList.add('collapsed');
              if(inner) inner.classList.add('collapsed');
              const btn = inner ? inner.querySelector('.collapse-btn') : null;
              if(btn){ btn.innerText = 'â—€'; btn.setAttribute('aria-expanded','false'); }
            } else {
              floating.classList.remove('collapsed');
              if(inner) inner.classList.remove('collapsed');
              const btn = inner ? inner.querySelector('.collapse-btn') : null;
              if(btn){ btn.innerText = 'â–¶'; btn.setAttribute('aria-expanded','true'); }
            }
            // sync input values
            const mainSearch=document.getElementById('searchInput'), floatSearch=document.getElementById('floatSearchInput');
            if(mainSearch && floatSearch) floatSearch.value = mainSearch.value;
            const mainMes=document.getElementById('mesSelect'), floatMes=document.getElementById('floatMesSelect');
            if(mainMes && floatMes) floatMes.value = mainMes.value;
          } catch(e){}

        }catch(e){}
      }
    });
  }, { root: null, threshold: 0, rootMargin: '0px' });

  observer.observe(mainBar);

  // After floating is created we add the subtle collapse/expand button and behavior.
  // We do this here to ensure elements exist and to keep functions unchanged.
  waitForFloatingAndInjectToggle();
}

/* Inject collapse/expand button and logic into floating filters */
function ensureFloatingToggle() {
  const floating = document.getElementById('floatingFilters');
  if(!floating) return;
  const inner = document.getElementById('floatingFiltersInner');
  if(!inner) return;

  // Avoid duplicate injection
  if(inner.querySelector('.collapse-btn')) return;

  // Create collapse/expand button
  const btn = document.createElement('button');
  btn.className = 'collapse-btn';
  btn.type = 'button';
  btn.setAttribute('aria-expanded', 'true');
  btn.title = 'Recolher / Expandir filtros';
  btn.innerText = 'â–¶'; // collapse indicator (collapses to the right)
  btn.style.marginLeft = '6px';
  btn.style.fontSize = '14px';
  btn.style.lineHeight = '1';
  btn.style.background = 'var(--tryvia-white)';
  btn.style.color = 'var(--tryvia-cyan)';

  inner.appendChild(btn);
  // Ensure button reflects current collapsed state on creation
  try{
    const floatingCollapsed = floating.classList.contains('collapsed') || inner.classList.contains('collapsed');
    if(floatingCollapsed){
      btn.innerText = 'â—€';
      btn.setAttribute('aria-expanded','false');
    }
  }catch(e){}

  function setCollapsedState(collapsed, save){
    if(collapsed){
      floating.classList.add('collapsed');
      inner.classList.add('collapsed');
      btn.innerText = 'â—€'; // show expand arrow (expand to the left)
      btn.setAttribute('aria-expanded','false');
    } else {
      floating.classList.remove('collapsed');
      inner.classList.remove('collapsed');
      btn.innerText = 'â–¶'; // show collapse arrow (collapse to the right)
      btn.setAttribute('aria-expanded','true');
    }
    if(save){
      try{ localStorage.setItem('floatingFiltersCollapsed','' + (collapsed?1:0)); }catch(e){}
    }
  }

  // Load saved preference but do not force collapsed on show â€” allow toggle but default is expanded when shown.
  let saved = null;
  try{ saved = localStorage.getItem('floatingFiltersCollapsed'); }catch(e){}
  // If user had previously collapsed and wants persistence, we still respect it only when they toggle.
  // But we avoid forcing collapsed state immediately; initial show will be expanded (handled in observer).

  btn.addEventListener('click', function(e){
    const isCollapsed = floating.classList.contains('collapsed');
    setCollapsedState(!isCollapsed, true);
    btn.focus();
    e.stopPropagation();
  });

  // Allow clicking search icon to expand and focus search
  const searchIcon = inner.querySelector('.search-icon');
  if(searchIcon){
    searchIcon.style.cursor = 'pointer';
    searchIcon.setAttribute('title','Buscar cliente');
    searchIcon.addEventListener('click', ()=> {
      if(floating.classList.contains('collapsed')) {
        // expand
        floating.classList.remove('collapsed');
        inner.classList.remove('collapsed');
        const btnLocal = inner.querySelector('.collapse-btn');
        if(btnLocal){ btnLocal.innerText = 'â–¶'; btnLocal.setAttribute('aria-expanded','true'); try{ localStorage.setItem('floatingFiltersCollapsed','0'); }catch(e){} }
        setTimeout(()=> {
          const floatInput = document.getElementById('floatSearchInput');
          if(floatInput) floatInput.focus();
        }, 220);
      } else {
        const floatInput = document.getElementById('floatSearchInput');
        if(floatInput) floatInput.focus();
      }
    });
  }

  // Keep in sync values between float and main search
  const floatInput = document.getElementById('floatSearchInput');
  const mainInput = document.getElementById('searchInput');
  if(floatInput && mainInput){
    const sync = ()=> { try{ if(mainInput.value !== floatInput.value) mainInput.value = floatInput.value; if(floatInput.value !== mainInput.value) floatInput.value = mainInput.value; }catch(e){} };
    floatInput.addEventListener('input', sync);
    mainInput.addEventListener('input', sync);
  }
}

function waitForFloatingAndInjectToggle(retries){
  retries = typeof retries === 'number' ? retries : 30;
  const inner = document.getElementById('floatingFiltersInner');
  if(inner){
    ensureFloatingToggle();
    return;
  }
  if(retries <= 0) return;
  setTimeout(()=> waitForFloatingAndInjectToggle(retries - 1), 160);
}

/* AUTOCOMPLETE SUGGESTIONS (new, added without modifying existing functions) */
/* Renders suggestions based on current registered clientes and the typed term.
   Keeps the UI responsive and integrates with existing filtering behavior.
*/
function renderSuggestions(){
  const mainInput = document.getElementById('searchInput');
  const mainBox = document.getElementById('searchSuggestions');
  const floatInput = document.getElementById('floatSearchInput');
  const floatBox = document.getElementById('floatSearchSuggestions');
  if(!mainInput && !floatInput) return;

  const activeIsFloat = (document.activeElement && document.activeElement.id === 'floatSearchInput');
  const input = activeIsFloat && floatInput ? floatInput : (mainInput || floatInput);
  const suggestionsBox = activeIsFloat && floatBox ? floatBox : (mainBox || floatBox);
  if(!suggestionsBox) return;

  // Close the other dropdown
  try{
    const other = suggestionsBox === mainBox ? floatBox : mainBox;
    if(other){ other.classList.remove('show'); other.setAttribute('aria-hidden','true'); other.innerHTML=''; }
  }catch(e){}

  const term = (input.value || '').toLowerCase().trim();
  // Build unique client list
  const names = Array.from(new Set((clientes || []).map(c => (c.nome || '').toString().trim()).filter(Boolean)))
    .filter(n => !term || n.toLowerCase().includes(term))
    .sort((a,b)=>a.localeCompare(b,'pt-BR',{sensitivity:'base'}));

  // Build header with actions and results list
  const listId = suggestionsBox === mainBox ? 'suggestListMain' : 'suggestListFloat';
  suggestionsBox.innerHTML = `
    <div style="display:flex;gap:6px;margin-bottom:6px;">
      <button class="btn" type="button" onclick="suggestSelectAll('${listId}')">Selecionar todos</button>
      <button class="btn" type="button" onclick="suggestClearAll('${listId}')">Limpar</button>
    </div>
    <div id="${listId}" style="display:flex;flex-direction:column;gap:6px;"></div>
  `;
  const listEl = document.getElementById(listId);
  if(names.length === 0){
    const p = document.createElement('div');
    p.className = 'suggestion-item';
    p.textContent = 'Nenhum cliente encontrado';
    listEl.appendChild(p);
  } else {
    names.forEach(name => {
      const id = 'sg_' + Math.random().toString(36).slice(2,9);
      const checked = selectedClients && selectedClients.has(name);
      const avg = getAverageCHSForName(name);
      const statusObj = getStatusCHS(Number(avg));
      const badgeColor = (statusObj && statusObj.cor) ? statusObj.cor : '#006f5a';
      const row = document.createElement('div');
      row.className = 'compare-selector-item';
      row.tabIndex = 0;
      row.innerHTML = `<input type=\"checkbox\" id=\"${id}\" data-name=\"${escapeHtml(name)}\" ${checked?'checked':''}/> <span class=\"client-name\" title=\"${escapeHtml(name)}\">${escapeHtml(name)}</span> <span class=\"chs-badge\" style=\"border-color:${badgeColor}; color:${badgeColor};\">${avg}</span>`;
      const input = row.querySelector('input');
      const toggle = ()=>{ input.checked = !input.checked; const n = input.getAttribute('data-name'); if(input.checked) selectedClients.add(n); else selectedClients.delete(n); updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard(); };
      input.addEventListener('change', ()=> toggle());
      row.addEventListener('click', (ev)=>{ if(ev.target && ev.target.tagName !== 'INPUT'){ toggle(); } });
      row.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); toggle(); } });
      listEl.appendChild(row);
    });
  }

  // match width with the input
  try{
    const w = Math.max(260, input.offsetWidth);
    suggestionsBox.style.minWidth = w + 'px';
    suggestionsBox.style.width = w + 'px';
    // align left edge with the input (account for search icon area)
    const left = input.offsetLeft || 0;
    suggestionsBox.style.left = left + 'px';
  }catch(e){}

  suggestionsBox.classList.add('show');
  suggestionsBox.setAttribute('aria-hidden','false');
}

function suggestSelectAll(listId){
  document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => { ch.checked = true; const n = ch.getAttribute('data-name'); if(n) selectedClients.add(n); });
  rankingPage = 1; renderDashboard();
}
function suggestClearAll(listId){
  document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => { ch.checked = false; const n = ch.getAttribute('data-name'); if(n) selectedClients.delete(n); });
  rankingPage = 1; renderDashboard();
}

/* When user selects a suggestion: populate search, trigger existing filtering and related UI updates */
function selectSuggestion(name){
  const mainInput = document.getElementById('searchInput');
  const floatInput = document.getElementById('floatSearchInput');
  const activeIsFloat = (document.activeElement && document.activeElement.id === 'floatSearchInput');
  const target = activeIsFloat && floatInput ? floatInput : mainInput;
  if(!target) return;
  target.value = name;
  // Sync the other input too
  try{
    if(target === mainInput && floatInput) floatInput.value = name;
    if(target === floatInput && mainInput) mainInput.value = name;
  }catch(e){}
  // Hide both suggestion boxes
  ['searchSuggestions','floatSearchSuggestions'].forEach(id=>{
    const box = document.getElementById(id);
    if(box){ box.classList.remove('show'); box.setAttribute('aria-hidden','true'); box.innerHTML=''; }
  });
  // Trigger existing filters and selectors to update
  filtrarClientes();
  renderCompareSelector();
  renderSelectModalList();
}

/* Keyboard navigation for suggestion list */
function handleSearchKeyDown(e){
  const mainBox = document.getElementById('searchSuggestions');
  const floatBox = document.getElementById('floatSearchSuggestions');
  const suggestionsBox = (floatBox && floatBox.classList.contains('show')) ? floatBox : mainBox;
  if(!suggestionsBox || !suggestionsBox.classList.contains('show')) return;
  const items = Array.from(suggestionsBox.querySelectorAll('.suggestion-item'));
  if(!items.length) return;
  let activeIndex = items.findIndex(it => it.classList.contains('active'));
  if(e.key === 'ArrowDown'){
    e.preventDefault();
    if(activeIndex >= 0) items[activeIndex].classList.remove('active');
    const next = (activeIndex + 1) % items.length;
    items[next].classList.add('active');
    items[next].scrollIntoView({block:'nearest'});
  } else if(e.key === 'ArrowUp'){
    e.preventDefault();
    if(activeIndex >= 0) items[activeIndex].classList.remove('active');
    const prev = (activeIndex - 1 + items.length) % items.length;
    items[prev].classList.add('active');
    items[prev].scrollIntoView({block:'nearest'});
  } else if(e.key === 'Enter'){
    if(activeIndex >= 0){
      e.preventDefault();
      const name = items[activeIndex].getAttribute('data-name');
      if(name) selectSuggestion(name);
    }
  } else if(e.key === 'Escape'){
    suggestionsBox.classList.remove('show');
    suggestionsBox.setAttribute('aria-hidden','true');
    suggestionsBox.innerHTML = '';
  }
}

/* Hide suggestions on blur, but allow click handlers (use timeout) */
function attachSearchHandlers(){
  const input = document.getElementById('searchInput');
  const suggestionsBox = document.getElementById('searchSuggestions');
  if(input){
    input.addEventListener('input', function(){
      renderSuggestions();
    });
    input.addEventListener('focus', function(){ renderSuggestions(); });
    input.addEventListener('keydown', function(e){ handleSearchKeyDown(e); });
    input.addEventListener('blur', function(){
      setTimeout(()=>{ 
        const sb = document.getElementById('searchSuggestions');
        const headerSearchMain = document.querySelector('.filters-left .header-search');
        const active = document.activeElement;
        if(headerSearchMain && (headerSearchMain.contains(active))){
          return;
        }
        if(sb) { sb.classList.remove('show'); sb.setAttribute('aria-hidden','true'); sb.innerHTML=''; }
      }, 60);
    });
  }
  if(suggestionsBox){
    suggestionsBox.addEventListener('blur', function(){
      setTimeout(()=>{ 
        const sb = document.getElementById('searchSuggestions');
        if(sb) { sb.classList.remove('show'); sb.setAttribute('aria-hidden','true'); sb.innerHTML=''; }
      }, 120);
    });
  }

  // If clicking outside, hide suggestions
  document.addEventListener('click', function(e){
    const target = e.target;
    const headerSearchMain = document.querySelector('.filters-left .header-search');
    const headerSearchFloat = document.querySelector('#floatingFiltersInner .header-search');
    const boxes = ['searchSuggestions','floatSearchSuggestions'];
    if((!headerSearchMain || !headerSearchMain.contains(target)) && (!headerSearchFloat || !headerSearchFloat.contains(target))){
      boxes.forEach(id=>{ const sb = document.getElementById(id); if(sb){ sb.classList.remove('show'); sb.setAttribute('aria-hidden','true'); sb.innerHTML=''; } });
    }
  });

  // Wire floating input as well (if exists)
  const floatInput = document.getElementById('floatSearchInput');
  const floatBox = document.getElementById('floatSearchSuggestions');
  if(floatInput){
    floatInput.addEventListener('input', function(){ renderSuggestions(); });
    floatInput.addEventListener('focus', function(){ renderSuggestions(); });
    floatInput.addEventListener('keydown', function(e){ handleSearchKeyDown(e); });
    floatInput.addEventListener('blur', function(){ 
      setTimeout(()=>{ 
        const headerSearchFloat = document.querySelector('#floatingFiltersInner .header-search');
        const active = document.activeElement;
        if(headerSearchFloat && headerSearchFloat.contains(active)){
          return;
        }
        if(floatBox){ floatBox.classList.remove('show'); floatBox.setAttribute('aria-hidden','true'); floatBox.innerHTML=''; }
      }, 60);
    });
  }
}

/* ========== End autocomplete helpers ========== */
/* Helper: show number of selected clients in the search inputs */
function updateSelectedClientsInputLabel(){
  // no-op: do not write into search inputs so it won't interfere with typing
}

/* ========== Inline multi-select below search inputs ========== */
function openInlineSelect(which){
  const isFloat = which === 'float';
  const boxId = isFloat ? 'floatSearchSuggestions' : 'searchSuggestions';
  const box = document.getElementById(boxId);
  if(!box) return;
  // Close other box first to avoid conflicts
  try{ const otherId = isFloat ? 'searchSuggestions' : 'floatSearchSuggestions'; const other = document.getElementById(otherId); if(other){ other.classList.remove('show'); other.setAttribute('aria-hidden','true'); other.innerHTML=''; } }catch(e){}
  // Render the container with internal search and list region
  const searchId = isFloat ? 'inlineSearchFloat' : 'inlineSearchMain';
  const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
  box.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:6px;">
      <input id="${searchId}" class="modal-search" placeholder="Buscar na lista..." />
      <div style="display:flex;gap:6px;">
        <button class="btn" type="button" onclick="inlineSelectAllVisible('${which}')">Selecionar todos</button>
        <button class="btn" type="button" onclick="inlineClearAllVisible('${which}')">Limpar</button>
      </div>
      <div id="${listId}" style="max-height:320px;overflow:auto;display:flex;flex-direction:column;gap:6px;"></div>
    </div>`;
  box.classList.add('show');
  box.setAttribute('aria-hidden','false');
  // match width with the input for a cleaner look
  try{
    const container = isFloat ? document.querySelector('#floatingFiltersInner .header-search') : document.querySelector('.filters-left .header-search');
    const input = isFloat ? document.getElementById('floatSearchInput') : document.getElementById('searchInput');
    if(container && input){
      const w = Math.max(260, input.offsetWidth);
      box.style.minWidth = w + 'px';
      box.style.width = w + 'px';
    }
  }catch(e){}
  renderInlineSelectList(which);
  setTimeout(()=>{ const s = document.getElementById(searchId); if(s) { s.focus(); s.addEventListener('input', ()=> renderInlineSelectList(which)); } }, 30);
}

function closeInlineSelect(){
  ['searchSuggestions','floatSearchSuggestions'].forEach(id=>{
    const el = document.getElementById(id);
    if(el){ el.classList.remove('show'); el.setAttribute('aria-hidden','true'); el.innerHTML=''; }
  });
}

function inlineGetBase(){
  // Always list all clients (independente do mÃªs selecionado)
  return clientes || [];
}

function renderInlineSelectList(which){
  const isFloat = which === 'float';
  const searchId = isFloat ? 'inlineSearchFloat' : 'inlineSearchMain';
  const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
  const listEl = document.getElementById(listId);
  if(!listEl) return;
  const term = (document.getElementById(searchId)?.value || '').toLowerCase().trim();
  const base = inlineGetBase();
  const names = Array.from(new Set(base.map(c=> (c.nome||'').toString().trim()).filter(Boolean)))
    .filter(n => !term || n.toLowerCase().includes(term))
    .sort((a,b)=> a.localeCompare(b,'pt-BR',{sensitivity:'base'}));
  listEl.innerHTML = '';
  if(names.length === 0){
    const p = document.createElement('div');
    p.style.color='var(--tryvia-dark2)'; p.style.fontWeight='700'; p.style.padding='8px';
    p.textContent='Nenhum cliente disponÃ­vel.';
    listEl.appendChild(p);
    return;
  }
  names.forEach(name => {
    const id = (isFloat?'ifl_':'im_') + Math.random().toString(36).slice(2,9);
    const checked = selectedClients && selectedClients.has(name);
    const row = document.createElement('div');
    row.className = 'compare-selector-item';
    row.tabIndex = 0;
    row.innerHTML = `<input type=\"checkbox\" id=\"${id}\" data-name=\"${escapeHtml(name)}\" ${checked?'checked':''} /> <span class=\"client-name\" title=\"${escapeHtml(name)}\">${escapeHtml(name)}</span> <span class=\"chs-badge\">${getAverageCHSForName(name)}</span>`;
    const input = row.querySelector('input');
    const toggle = ()=>{ input.checked = !input.checked; const n = input.getAttribute('data-name'); if(input.checked) selectedClients.add(n); else selectedClients.delete(n); updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard(); };
    input.addEventListener('change', ()=> toggle());
    row.addEventListener('click', (ev)=>{ if(ev.target && ev.target.tagName !== 'INPUT'){ toggle(); } });
    row.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter' || ev.key === ' '){ ev.preventDefault(); toggle(); } });
    listEl.appendChild(row);
  });
}

function inlineSelectAllVisible(which){
  const isFloat = which === 'float';
  const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
  document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => {
    ch.checked = true; const n = ch.getAttribute('data-name'); if(n) selectedClients.add(n);
  });
  updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard();
}
function inlineClearAllVisible(which){
  const isFloat = which === 'float';
  const listId = isFloat ? 'inlineListFloat' : 'inlineListMain';
  document.querySelectorAll(`#${listId} input[type="checkbox"]`).forEach(ch => {
    ch.checked = false; const n = ch.getAttribute('data-name'); if(n) selectedClients.delete(n);
  });
  updateSelectedClientsInputLabel(); rankingPage = 1; renderDashboard();
}

/* ========== Toggle extra charts (Ver Mais / Ver Menos) ========== */
function toggleGraficos(){
  const cont = document.getElementById('graficosIndividuais');
  const btn = document.getElementById('toggleGraficosBtn');
  if(!cont || !btn) return;
  const isHidden = cont.style.display === 'none' || cont.getAttribute('aria-hidden') === 'true' || !cont.classList.contains('expanded');
  if(isHidden){
    cont.style.display = 'block';
    cont.classList.add('collapsible');
    // Force reflow to enable transition
    void cont.offsetHeight;
    cont.classList.add('expanded');
    cont.setAttribute('aria-hidden','false');
    btn.textContent = 'Ver Menos';
    // After expansion, ensure charts size correctly (if created while hidden)
    setTimeout(()=>{
      try{ chartTrendUp ? chartTrendUp.resize() : createChartTrendUp(); }catch(e){}
      try{ chartIndicadores ? chartIndicadores.resize() : createChartIndicadores(); }catch(e){}
    }, 380);
  } else {
    cont.classList.remove('expanded');
    cont.setAttribute('aria-hidden','true');
    const onEnd = (ev)=>{ if(ev.target!==cont) return; cont.style.display='none'; cont.removeEventListener('transitionend', onEnd); };
    cont.addEventListener('transitionend', onEnd);
    btn.textContent = 'Ver Mais';
  }
}

// ====== TV Mode (one-screen view) ======
function resizeAllChartsForTv(){
  try{ chartChsDistrib ? chartChsDistrib.resize() : createChartDistribuicao(); }catch(e){}
  try{ chartChsEvolucao ? chartChsEvolucao.resize() : createChartEvolucao(); }catch(e){}
  try{ chartTrendUp ? chartTrendUp.resize() : createChartTrendUp(); }catch(e){}
  try{ chartNegEvolucao ? chartNegEvolucao.resize() : createChartNEG(); }catch(e){}
  try{ chartIndicadores ? chartIndicadores.resize() : createChartIndicadores(); }catch(e){}
}

function normalizeChartsDPR(){
  const dpr = window.devicePixelRatio || 1;
  const charts = [
    typeof chartChsDistrib!=='undefined'?chartChsDistrib:null,
    typeof chartChsEvolucao!=='undefined'?chartChsEvolucao:null,
    typeof chartTrendUp!=='undefined'?chartTrendUp:null,
    typeof chartTrendDown!=='undefined'?chartTrendDown:null,
    typeof chartSlaEvolucao!=='undefined'?chartSlaEvolucao:null,
    typeof chartCsEvolucao!=='undefined'?chartCsEvolucao:null,
    typeof chartNpsEvolucao!=='undefined'?chartNpsEvolucao:null,
    typeof chartNegEvolucao!=='undefined'?chartNegEvolucao:null,
    typeof chartIndicadores!=='undefined'?chartIndicadores:null,
    typeof chartCompare!=='undefined'?chartCompare:null,
    typeof chartClienteDonut!=='undefined'?chartClienteDonut:null,
    typeof chartClienteComp!=='undefined'?chartClienteComp:null,
    typeof chartClienteTrendDown!=='undefined'?chartClienteTrendDown:null,
    typeof chartClienteTrendUp!=='undefined'?chartClienteTrendUp:null
  ];
  charts.forEach(ch=>{ try{ if(ch){ ch.options.devicePixelRatio = dpr; ch.resize(0); ch.update('none'); } }catch(e){} });
}

// TV mode scaling state and debounced updater to prevent jitter
let __tvScaling = false;
let __tvLastScale = null;
let __tvResizeTimer = null;
function scheduleTvLayoutUpdate(delay){
  const ms = typeof delay === 'number' ? delay : 120;
  if(__tvResizeTimer) clearTimeout(__tvResizeTimer);
  __tvResizeTimer = setTimeout(()=>{ applyTvScale(); normalizeChartsDPR(); resizeAllChartsForTv(); }, ms);
}

function applyTvScale(){
  const body = document.body;
  const cont = document.querySelector('.container');
  if(!cont) return;
  if(!body.classList.contains('tv-mode')){
    cont.style.transform = '';
    cont.style.height = '';
    cont.style.width = '';
    cont.style.margin = '';
    // restore ranking dynamic heights
    document.querySelectorAll('.dashboard-ranking-container').forEach(rc=>{ rc.style.height=''; });
    document.querySelectorAll('.dashboard-ranking-list,#rankingGeralList').forEach(ul=>{ ul.style.maxHeight=''; });
    // restore chart container heights
    document.querySelectorAll('.dashboard-chart-container').forEach(cc=>{ cc.style.height=''; });
    return;
  }
  // reset to measure (previous behavior: height-based scaling)
  if(__tvScaling) return; // guard re-entrancy
  __tvScaling = true;
  cont.style.transform = '';
  cont.style.height = '';
  const withSidebar = cont.classList.contains('with-sidebar');
  cont.style.width = withSidebar ? 'calc(100vw - 88px)' : '100vw';
  const desiredBottomGap = 12;
  const availH = window.innerHeight;
  let contentH = cont.scrollHeight;
  // If there's vertical gap, increase ranking heights to fill it proportionally
  const ranks = Array.from(document.querySelectorAll('.dashboard-ranking-container'));
  if(ranks.length){
    const baseH = 420;        // keep in sync with TV CSS
    const baseListH = 352;    // keep in sync with TV CSS
    let extra = availH - desiredBottomGap - contentH;
    if(extra > 0){
      const per = Math.floor(extra / ranks.length);
      const perClamped = Math.min(per, 140);
      ranks.forEach(rc=>{ rc.style.height = (baseH + perClamped) + 'px'; });
      document.querySelectorAll('.dashboard-ranking-list,#rankingGeralList').forEach(ul=>{ ul.style.maxHeight = (baseListH + perClamped) + 'px'; });
      // remeasure after adjustment
      contentH = cont.scrollHeight;
    }
  }
  // Then, if still vertical gap, expand charts heights as well to keep proportions
  const charts = Array.from(document.querySelectorAll('.dashboard-chart-container'));
  if(charts.length){
    const baseChartH = 420;   // keep in sync with TV CSS
    let extra2 = availH - desiredBottomGap - contentH;
    if(extra2 > 0){
      const perC = Math.floor(extra2 / charts.length);
      const perCClamped = Math.min(perC, 120);
      charts.forEach(cc=>{ cc.style.height = (baseChartH + perCClamped) + 'px'; });
      // remeasure after adjustment
      contentH = cont.scrollHeight;
    }
  }
  const parentW = (cont.parentElement && cont.parentElement.clientWidth) ? cont.parentElement.clientWidth : (window.innerWidth || document.documentElement.clientWidth || 0);
  const baseW = Math.max(parentW, 0);
  const vwWidth = Math.max(withSidebar ? (baseW - 88) : baseW, 0);
  const contentW = Math.max(cont.scrollWidth || cont.offsetWidth || 0, 0);
  const sY = (availH - desiredBottomGap) / (contentH || 1);
  const sX = vwWidth / (contentW || 1);
  const scale = Math.min(1, sX, sY);
  if(__tvLastScale !== null && Math.abs(scale - __tvLastScale) < 0.002){
    __tvScaling = false;
    return;
  }
  cont.style.transformOrigin = 'top center';
  cont.style.transform = 'scale(' + scale.toFixed(3) + ')';
  cont.style.height = (contentH * scale) + 'px';
  // Expand logical width so that after scale the visible width occupies 100vw (avoid side gaps)
  try{
    cont.style.width = (vwWidth / (scale || 1)) + 'px';
  }catch(e){ cont.style.width = '100vw'; }
  cont.style.margin = '0 auto';
  __tvLastScale = scale;
  __tvScaling = false;
}

function isFullscreen(){ return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
function fsElement(){ return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || null; }
function requestFs(el){ if(!el) return; if(el.requestFullscreen) return el.requestFullscreen(); if(el.webkitRequestFullscreen) return el.webkitRequestFullscreen(); if(el.msRequestFullscreen) return el.msRequestFullscreen(); }
function exitFs(){ if(document.exitFullscreen) return document.exitFullscreen(); if(document.webkitExitFullscreen) return document.webkitExitFullscreen(); if(document.msExitFullscreen) return document.msExitFullscreen(); }
function resizeChartsInside(el){ try{ const ids = Array.from(el.querySelectorAll('canvas[id]')).map(c=>c.id);
  try{ if(ids.includes('chartChsDistrib') && typeof chartChsDistrib!=='undefined' && chartChsDistrib) chartChsDistrib.resize(); }catch(e){}
  try{ if(ids.includes('chartChsEvolucao') && typeof chartChsEvolucao!=='undefined' && chartChsEvolucao) chartChsEvolucao.resize(); }catch(e){}
  try{ if(ids.includes('chartTrendUp') && typeof chartTrendUp!=='undefined' && chartTrendUp) chartTrendUp.resize(); }catch(e){}
  try{ if(ids.includes('chartIndicadores') && typeof chartIndicadores!=='undefined' && chartIndicadores) chartIndicadores.resize(); }catch(e){}
}catch(e){}
try{ window.dispatchEvent(new Event('resize')); }catch(e){} }
function toggleElementFullscreen(btn){ const el = btn && btn.closest ? btn.closest('.dashboard-chart-container, .dashboard-ranking-container') : null; if(!el) return; if(isFullscreen() && fsElement()===el){ exitFs(); } else { requestFs(el); } }
document.addEventListener('fullscreenchange', function(){
  const el = fsElement();
  if(el){ resizeChartsInside(el); } else { try{ resizeAllChartsForTv(); }catch(e){} }
  // Only adjust Ranking Geral page size while its container is fullscreen
  try{
    const rg = document.getElementById('rankingGeral');
    if(el && rg && el===rg){
      try{ if(typeof window.__rg_fs_prevPageSize === 'undefined' || window.__rg_fs_prevPageSize === null) window.__rg_fs_prevPageSize = rankingPageSize; }catch(e){}
      try{ if(typeof rankingPageSize !== 'undefined' && rankingPageSize < 10) rankingPageSize = 10; }catch(e){}
      try{ renderRankingGeral(); }catch(e){}
    } else if(!el && (typeof window.__rg_fs_prevPageSize !== 'undefined') && window.__rg_fs_prevPageSize !== null){
      try{ rankingPageSize = window.__rg_fs_prevPageSize; }catch(e){}
      window.__rg_fs_prevPageSize = null;
      try{ renderRankingGeral(); }catch(e){}
    }
  }catch(e){}
});
document.addEventListener('webkitfullscreenchange', function(){
  const el = fsElement();
  if(el){ resizeChartsInside(el); } else { try{ resizeAllChartsForTv(); }catch(e){} }
  // Only adjust Ranking Geral page size while its container is fullscreen
  try{
    const rg = document.getElementById('rankingGeral');
    if(el && rg && el===rg){
      try{ if(typeof window.__rg_fs_prevPageSize === 'undefined' || window.__rg_fs_prevPageSize === null) window.__rg_fs_prevPageSize = rankingPageSize; }catch(e){}
      try{ if(typeof rankingPageSize !== 'undefined' && rankingPageSize < 10) rankingPageSize = 10; }catch(e){}
      try{ renderRankingGeral(); }catch(e){}
    } else if(!el && (typeof window.__rg_fs_prevPageSize !== 'undefined') && window.__rg_fs_prevPageSize !== null){
      try{ rankingPageSize = window.__rg_fs_prevPageSize; }catch(e){}
      window.__rg_fs_prevPageSize = null;
      try{ renderRankingGeral(); }catch(e){}
    }
  }catch(e){}
});
function attachFullscreenHandlers(){ /* dblclick to fullscreen disabled intentionally; use button only */ }
// TV helpers: sidebar and chart defaults
function ensureTvSidebar(enable){
  try{
    const cont = document.querySelector('.container');
    let sidebar = document.getElementById('tvSidebar');
    if(enable){
      if(!sidebar){
        sidebar = document.createElement('div');
        sidebar.id = 'tvSidebar';
        sidebar.className = 'tv-sidebar';
        sidebar.innerHTML = '<div class="tv-brand">TV</div>' +
                            '<div class="tv-nav">' +
                            '  <button class="tv-nav-item" data-nav="resumo">Resumo</button>' +
                            '  <button class="tv-nav-item" data-nav="clientes">Clientes</button>' +
                            '  <button class="tv-nav-item" data-nav="tendencias">TendÃªncias</button>' +
                            '  <button class="tv-nav-item" data-nav="alertas">Alertas</button>' +
                            '</div>';
        document.body.appendChild(sidebar);
      }
      if(cont) cont.classList.add('with-sidebar');
    } else {
      if(sidebar){ try{ sidebar.remove(); }catch(e){} }
      if(cont) cont.classList.remove('with-sidebar');
    }
  }catch(e){}
}
let __tvChartsConfigured = false;
function configureChartsForTv(enable){
  try{
    if(typeof Chart === 'undefined') return;
    if(enable){
      Chart.defaults.font = Chart.defaults.font || {};
      Chart.defaults.font.family = "'Poppins','Roboto',Arial,sans-serif";
      Chart.defaults.font.size = 12;
      Chart.defaults.color = '#102a43';
      Chart.defaults.borderColor = '#e8eef3';
      Chart.defaults.scale = Chart.defaults.scale || {};
      Chart.defaults.scale.grid = Chart.defaults.scale.grid || {};
      Chart.defaults.scale.grid.color = '#edf3f7';
      Chart.defaults.scale.ticks = Chart.defaults.scale.ticks || {};
      Chart.defaults.scale.ticks.color = '#6b7d8c';
      Chart.defaults.plugins = Chart.defaults.plugins || {};
      Chart.defaults.plugins.legend = Chart.defaults.plugins.legend || {};
      Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
      Chart.defaults.plugins.legend.labels.boxWidth = 10;
      Chart.defaults.plugins.tooltip = Chart.defaults.plugins.tooltip || {};
      Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(16,42,67,0.92)';
      Chart.defaults.plugins.tooltip.titleColor = '#fff';
      Chart.defaults.plugins.tooltip.bodyColor = '#fff';
      Chart.defaults.elements = Chart.defaults.elements || {};
      Chart.defaults.elements.point = Chart.defaults.elements.point || {};
      Chart.defaults.elements.point.radius = 3;
      Chart.defaults.elements.line = Chart.defaults.elements.line || {};
      Chart.defaults.elements.line.borderWidth = 3;
      __tvChartsConfigured = true;
    } else {
      // revert to sane defaults
      Chart.defaults.font = Chart.defaults.font || {};
      Chart.defaults.font.family = "'Roboto',Arial,sans-serif";
      Chart.defaults.font.size = 12;
      Chart.defaults.color = '#333';
      Chart.defaults.borderColor = '#e0e0e0';
      Chart.defaults.scale = Chart.defaults.scale || {};
      Chart.defaults.scale.grid = Chart.defaults.scale.grid || {};
      Chart.defaults.scale.grid.color = '#eeeeee';
      Chart.defaults.scale.ticks = Chart.defaults.scale.ticks || {};
      Chart.defaults.scale.ticks.color = '#666';
      Chart.defaults.plugins = Chart.defaults.plugins || {};
      Chart.defaults.plugins.legend = Chart.defaults.plugins.legend || {};
      Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
      Chart.defaults.plugins.legend.labels.boxWidth = 12;
      Chart.defaults.plugins.tooltip = Chart.defaults.plugins.tooltip || {};
      Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0,0,0,0.8)';
      Chart.defaults.plugins.tooltip.titleColor = '#fff';
      Chart.defaults.plugins.tooltip.bodyColor = '#fff';
      Chart.defaults.elements = Chart.defaults.elements || {};
      Chart.defaults.elements.point = Chart.defaults.elements.point || {};
      Chart.defaults.elements.point.radius = 3;
      Chart.defaults.elements.line = Chart.defaults.elements.line || {};
      Chart.defaults.elements.line.borderWidth = 2;
      __tvChartsConfigured = false;
    }
  }catch(e){}
}
function toggleTvMode(){
  const body = document.body;
  const btn = document.getElementById('tvModeBtn');
  const enable = !body.classList.contains('tv-mode');
  body.classList.toggle('tv-mode');
  try{ document.documentElement.classList.toggle('tv-html', enable); }catch(e){}
  if(btn) btn.textContent = enable ? 'Sair da TV' : 'VisualizaÃ§Ã£o na TV';
  try{ localStorage.setItem('tvMode', enable ? '1' : '0'); }catch(e){}
  // Adjust ranking page size to fit more items in TV mode
  try{ window.__origRankingPageSize = window.__origRankingPageSize || rankingPageSize; }catch(e){}
  try{ if(enable) { rankingPageSize = 20; } else { rankingPageSize = window.__origRankingPageSize || 10; } }catch(e){}
  // Sidebar and chart defaults
  ensureTvSidebar(enable);
  configureChartsForTv(enable);
  try{
    const inIframe = (function(){ try{ return window.self !== window.top; }catch(e){ return true; } })();
    if(enable){ if(!isFullscreen() && !inIframe) requestFs(document.documentElement); }
    else { if(isFullscreen()) exitFs(); }
  }catch(e){}
  window.scrollTo(0,0);
  applyTvLayoutReflow(enable);
  setTimeout(()=>{ applyTvScale(); normalizeChartsDPR(); resizeAllChartsForTv(); }, 140);
}

function applyTvLayoutReflow(enable){
  try{
    const rankingGeral = document.getElementById('rankingGeral');
    if(!rankingGeral) return;
    const rows = Array.from(document.querySelectorAll('.dashboard-rankings-row'));
    // Charts reflow: move TrendUp and Indicadores into the first charts row to have 4 side-by-side
    const chsDistribCanvas = document.getElementById('chartChsDistrib');
    const mainChartsRow = chsDistribCanvas ? chsDistribCanvas.closest('.dashboard-charts-row') : null;
    const trendContainer = (document.getElementById('chartTrendUp')||{}).closest ? document.getElementById('chartTrendUp').closest('.dashboard-chart-container') : null;
    const indContainer = (document.getElementById('chartIndicadores')||{}).closest ? document.getElementById('chartIndicadores').closest('.dashboard-chart-container') : null;
    // Summary reflow: move CHS Geral into summary row so all five are on one line
    const chsBox = document.getElementById('chsGeralBox');
    const summaryRow = document.getElementById('chs-summary');
    if(enable){
      // Save original position
      tvRankingParentOrig = rankingGeral.parentElement || null;
      tvRankingNextSibling = rankingGeral.nextElementSibling || null;
      if(chsBox){ tvChsParentOrig = chsBox.parentElement || null; tvChsNextSibling = chsBox.nextElementSibling || null; }
      // Move to first rankings row
      if(rows[0]){
        rows[0].classList.add('tv-three');
        rows[0].appendChild(rankingGeral);
      }
      if(rows[1]) rows[1].style.display = 'none';
      // Charts: move extra two charts into first row
      if(mainChartsRow){
        if(trendContainer){ tvTrendParentOrig = trendContainer.parentElement; tvTrendNextSibling = trendContainer.nextElementSibling; mainChartsRow.classList.add('tv-four'); mainChartsRow.appendChild(trendContainer); }
        if(indContainer){ tvIndParentOrig = indContainer.parentElement; tvIndNextSibling = indContainer.nextElementSibling; mainChartsRow.classList.add('tv-four'); mainChartsRow.appendChild(indContainer); }
      }
      // Move CHS Geral box into summary row
      if(chsBox && summaryRow){ summaryRow.appendChild(chsBox); }
    } else {
      // Restore to original position
      if(tvRankingParentOrig){
        if(tvRankingNextSibling) tvRankingParentOrig.insertBefore(rankingGeral, tvRankingNextSibling);
        else tvRankingParentOrig.appendChild(rankingGeral);
      }
      if(rows[0]) rows[0].classList.remove('tv-three');
      if(rows[1]) rows[1].style.display = '';
      // Restore charts
      if(trendContainer && tvTrendParentOrig){ if(tvTrendNextSibling) tvTrendParentOrig.insertBefore(trendContainer, tvTrendNextSibling); else tvTrendParentOrig.appendChild(trendContainer); }
      if(indContainer && tvIndParentOrig){ if(tvIndNextSibling) tvIndParentOrig.insertBefore(indContainer, tvIndNextSibling); else tvIndParentOrig.appendChild(indContainer); }
      if(mainChartsRow) mainChartsRow.classList.remove('tv-four');
      // Restore CHS Geral box to original container
      if(chsBox && tvChsParentOrig){ if(tvChsNextSibling) tvChsParentOrig.insertBefore(chsBox, tvChsNextSibling); else tvChsParentOrig.appendChild(chsBox); }
    }
  }catch(e){}
}

/* Init */
document.addEventListener('DOMContentLoaded', function() {
  try{ carregarDoGoogleSheets(); }catch(e){}
  clientesFiltrados = [...clientes];
  const sel = document.getElementById('mesSelect');
  if(sel){
    const meses = Array.from(new Set((clientes || []).map(c=>c.dataFmt).filter(Boolean))).sort();
    const defaultMes = meses.length ? meses[meses.length - 1] : 'all';
    currentMes = defaultMes;
    sel.innerHTML = `<option value="all">Todos</option>` + meses.map(m=>`<option value="${m}">${formatMesAno(m)}</option>`).join('');
    sel.value = defaultMes;
  }
  selectedClients = new Set(Array.from(new Set((clientes||[]).map(c=> (c.nome||'').toString().trim()))));
  compareSelectedClients = new Set();
  populateCompareMonthSelects();
  renderSelectModalList();
  renderCompareSelector();
  renderDashboard();

  // initialize floating filters wiring and observer and inject toggle
  initFiltersObserver();

  // Attach autocomplete handlers
  attachSearchHandlers();

  // Close filters menu on outside click and ESC
  document.addEventListener('click', function(e){
    const wrap = document.getElementById('rankingFiltersWrap');
    const menu = document.getElementById('rankingFiltersMenu');
    if(!wrap || !menu) return;
    if(!wrap.contains(e.target)) closeRankingFiltersMenu();
  });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') closeRankingFiltersMenu();
  });
  // Close indicator filters menu on outside click and ESC
  document.addEventListener('click', function(e){
    const wrap = document.getElementById('indicatorFiltersWrap');
    const menu = document.getElementById('indicatorFiltersMenu');
    if(!wrap || !menu) return;
    if(!wrap.contains(e.target)) closeIndicatorFiltersMenu();
  });
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') closeIndicatorFiltersMenu();
  });
  // Exit TV mode with ESC
  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && document.body.classList.contains('tv-mode')){
      toggleTvMode();
    }
  });
  // Initialize TV mode from storage
  try{
    const tv = localStorage.getItem('tvMode');
    if(tv === '1'){
      document.body.classList.add('tv-mode');
      try{ document.documentElement.classList.add('tv-html'); }catch(e){}
      const btn = document.getElementById('tvModeBtn');
      if(btn) btn.textContent = 'Sair da TV';
      try{ window.__origRankingPageSize = rankingPageSize; rankingPageSize = 20; }catch(e){}
      ensureTvSidebar(true);
      configureChartsForTv(true);
      applyTvLayoutReflow(true);
      setTimeout(()=>{ applyTvScale(); normalizeChartsDPR(); resizeAllChartsForTv(); }, 200);
    }
  }catch(e){}
  // Keep scale responsive
  window.addEventListener('resize', function(){
    if(document.body.classList.contains('tv-mode')){
      scheduleTvLayoutUpdate(140);
    }
  });
  try{
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', function(){
        if(document.body.classList.contains('tv-mode')){
          scheduleTvLayoutUpdate(140);
        }
      });
    }
  }catch(e){}
  attachFullscreenHandlers();
});

/* small helpers used by pagination buttons - kept as expected */
function rankingPrev(){ if(rankingPage>1){ rankingPage--; renderRankingGeral(); } }
function rankingNext(){ rankingPage++; renderRankingGeral(); }
function verDetalhes(name){ abrirClienteModal(name); }
function editarCliente(name){ alert('Funcionalidade de editar nÃ£o implementada aqui.'); }
function ligarCliente(name){ alert('Funcionalidade de ligar nÃ£o implementada aqui.'); }

</script>
<button class="tv-exit-btn" type="button" onclick="toggleTvMode()">Sair da TV</button>
</body>
</html>